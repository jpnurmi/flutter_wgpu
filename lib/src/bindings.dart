// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// https://github.com/gfx-rs/wgpu-native
class LibWGPU {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  LibWGPU(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  void wgpu_adapter_destroy(
    int adapter_id,
  ) {
    return (_wgpu_adapter_destroy ??= _dylib.lookupFunction<
        _c_wgpu_adapter_destroy,
        _dart_wgpu_adapter_destroy>('wgpu_adapter_destroy'))(
      adapter_id,
    );
  }

  _dart_wgpu_adapter_destroy? _wgpu_adapter_destroy;

  int wgpu_adapter_features(
    int adapter_id,
  ) {
    return (_wgpu_adapter_features ??= _dylib.lookupFunction<
        _c_wgpu_adapter_features,
        _dart_wgpu_adapter_features>('wgpu_adapter_features'))(
      adapter_id,
    );
  }

  _dart_wgpu_adapter_features? _wgpu_adapter_features;

  /// Fills the given `info` struct with the adapter info.
  ///
  /// # Safety
  ///
  /// The field `info.name` is expected to point to a pre-allocated memory
  /// location. This function is unsafe as there is no guarantee that the
  /// pointer is valid and big enough to hold the adapter name.
  void wgpu_adapter_get_info(
    int adapter_id,
    ffi.Pointer<WGPUCAdapterInfo> info,
  ) {
    return (_wgpu_adapter_get_info ??= _dylib.lookupFunction<
        _c_wgpu_adapter_get_info,
        _dart_wgpu_adapter_get_info>('wgpu_adapter_get_info'))(
      adapter_id,
      info,
    );
  }

  _dart_wgpu_adapter_get_info? _wgpu_adapter_get_info;

  WGPUCLimits wgpu_adapter_limits(
    int adapter_id,
  ) {
    return (_wgpu_adapter_limits ??= _dylib.lookupFunction<
        _c_wgpu_adapter_limits,
        _dart_wgpu_adapter_limits>('wgpu_adapter_limits'))(
      adapter_id,
    );
  }

  _dart_wgpu_adapter_limits? _wgpu_adapter_limits;

  int wgpu_adapter_request_device(
    int adapter_id,
    int features,
    ffi.Pointer<WGPUCLimits> limits,
    bool shader_validation,
    ffi.Pointer<ffi.Int8> trace_path,
  ) {
    return (_wgpu_adapter_request_device ??= _dylib.lookupFunction<
        _c_wgpu_adapter_request_device,
        _dart_wgpu_adapter_request_device>('wgpu_adapter_request_device'))(
      adapter_id,
      features,
      limits,
      shader_validation ? 1 : 0,
      trace_path,
    );
  }

  _dart_wgpu_adapter_request_device? _wgpu_adapter_request_device;

  void wgpu_bind_group_destroy(
    int bind_group_id,
  ) {
    return (_wgpu_bind_group_destroy ??= _dylib.lookupFunction<
        _c_wgpu_bind_group_destroy,
        _dart_wgpu_bind_group_destroy>('wgpu_bind_group_destroy'))(
      bind_group_id,
    );
  }

  _dart_wgpu_bind_group_destroy? _wgpu_bind_group_destroy;

  void wgpu_bind_group_layout_destroy(
    int bind_group_layout_id,
  ) {
    return (_wgpu_bind_group_layout_destroy ??= _dylib.lookupFunction<
            _c_wgpu_bind_group_layout_destroy,
            _dart_wgpu_bind_group_layout_destroy>(
        'wgpu_bind_group_layout_destroy'))(
      bind_group_layout_id,
    );
  }

  _dart_wgpu_bind_group_layout_destroy? _wgpu_bind_group_layout_destroy;

  void wgpu_buffer_destroy(
    int buffer_id,
  ) {
    return (_wgpu_buffer_destroy ??= _dylib.lookupFunction<
        _c_wgpu_buffer_destroy,
        _dart_wgpu_buffer_destroy>('wgpu_buffer_destroy'))(
      buffer_id,
    );
  }

  _dart_wgpu_buffer_destroy? _wgpu_buffer_destroy;

  ffi.Pointer<ffi.Uint8> wgpu_buffer_get_mapped_range(
    int buffer_id,
    int start,
    int size,
  ) {
    return (_wgpu_buffer_get_mapped_range ??= _dylib.lookupFunction<
        _c_wgpu_buffer_get_mapped_range,
        _dart_wgpu_buffer_get_mapped_range>('wgpu_buffer_get_mapped_range'))(
      buffer_id,
      start,
      size,
    );
  }

  _dart_wgpu_buffer_get_mapped_range? _wgpu_buffer_get_mapped_range;

  void wgpu_buffer_map_read_async(
    int buffer_id,
    int start,
    int size,
    ffi.Pointer<ffi.NativeFunction<WGPUBufferMapCallback>> callback,
    ffi.Pointer<ffi.Uint8> user_data,
  ) {
    return (_wgpu_buffer_map_read_async ??= _dylib.lookupFunction<
        _c_wgpu_buffer_map_read_async,
        _dart_wgpu_buffer_map_read_async>('wgpu_buffer_map_read_async'))(
      buffer_id,
      start,
      size,
      callback,
      user_data,
    );
  }

  _dart_wgpu_buffer_map_read_async? _wgpu_buffer_map_read_async;

  void wgpu_buffer_map_write_async(
    int buffer_id,
    int start,
    int size,
    ffi.Pointer<ffi.NativeFunction<WGPUBufferMapCallback>> callback,
    ffi.Pointer<ffi.Uint8> user_data,
  ) {
    return (_wgpu_buffer_map_write_async ??= _dylib.lookupFunction<
        _c_wgpu_buffer_map_write_async,
        _dart_wgpu_buffer_map_write_async>('wgpu_buffer_map_write_async'))(
      buffer_id,
      start,
      size,
      callback,
      user_data,
    );
  }

  _dart_wgpu_buffer_map_write_async? _wgpu_buffer_map_write_async;

  void wgpu_buffer_unmap(
    int buffer_id,
  ) {
    return (_wgpu_buffer_unmap ??=
        _dylib.lookupFunction<_c_wgpu_buffer_unmap, _dart_wgpu_buffer_unmap>(
            'wgpu_buffer_unmap'))(
      buffer_id,
    );
  }

  _dart_wgpu_buffer_unmap? _wgpu_buffer_unmap;

  void wgpu_command_buffer_destroy(
    int command_buffer_id,
  ) {
    return (_wgpu_command_buffer_destroy ??= _dylib.lookupFunction<
        _c_wgpu_command_buffer_destroy,
        _dart_wgpu_command_buffer_destroy>('wgpu_command_buffer_destroy'))(
      command_buffer_id,
    );
  }

  _dart_wgpu_command_buffer_destroy? _wgpu_command_buffer_destroy;

  /// # Safety
  ///
  /// This function is unsafe because improper use may lead to memory
  /// problems. For example, a double-free may occur if the function is called
  /// twice on the same raw pointer.
  ffi.Pointer<WGPUComputePass> wgpu_command_encoder_begin_compute_pass(
    int encoder_id,
    ffi.Pointer<WGPUComputePassDescriptor> _desc,
  ) {
    return (_wgpu_command_encoder_begin_compute_pass ??= _dylib.lookupFunction<
            _c_wgpu_command_encoder_begin_compute_pass,
            _dart_wgpu_command_encoder_begin_compute_pass>(
        'wgpu_command_encoder_begin_compute_pass'))(
      encoder_id,
      _desc,
    );
  }

  _dart_wgpu_command_encoder_begin_compute_pass?
      _wgpu_command_encoder_begin_compute_pass;

  /// # Safety
  ///
  /// This function is unsafe because improper use may lead to memory
  /// problems. For example, a double-free may occur if the function is called
  /// twice on the same raw pointer.
  ffi.Pointer<WGPURenderPass> wgpu_command_encoder_begin_render_pass(
    int encoder_id,
    ffi.Pointer<WGPURenderPassDescriptor> desc,
  ) {
    return (_wgpu_command_encoder_begin_render_pass ??= _dylib.lookupFunction<
            _c_wgpu_command_encoder_begin_render_pass,
            _dart_wgpu_command_encoder_begin_render_pass>(
        'wgpu_command_encoder_begin_render_pass'))(
      encoder_id,
      desc,
    );
  }

  _dart_wgpu_command_encoder_begin_render_pass?
      _wgpu_command_encoder_begin_render_pass;

  void wgpu_command_encoder_copy_buffer_to_buffer(
    int command_encoder_id,
    int source,
    int source_offset,
    int destination,
    int destination_offset,
    int size,
  ) {
    return (_wgpu_command_encoder_copy_buffer_to_buffer ??=
        _dylib.lookupFunction<_c_wgpu_command_encoder_copy_buffer_to_buffer,
                _dart_wgpu_command_encoder_copy_buffer_to_buffer>(
            'wgpu_command_encoder_copy_buffer_to_buffer'))(
      command_encoder_id,
      source,
      source_offset,
      destination,
      destination_offset,
      size,
    );
  }

  _dart_wgpu_command_encoder_copy_buffer_to_buffer?
      _wgpu_command_encoder_copy_buffer_to_buffer;

  void wgpu_command_encoder_copy_buffer_to_texture(
    int command_encoder_id,
    ffi.Pointer<WGPUBufferCopyView> source,
    ffi.Pointer<WGPUTextureCopyView> destination,
    ffi.Pointer<WGPUExtent3d> copy_size,
  ) {
    return (_wgpu_command_encoder_copy_buffer_to_texture ??=
        _dylib.lookupFunction<_c_wgpu_command_encoder_copy_buffer_to_texture,
                _dart_wgpu_command_encoder_copy_buffer_to_texture>(
            'wgpu_command_encoder_copy_buffer_to_texture'))(
      command_encoder_id,
      source,
      destination,
      copy_size,
    );
  }

  _dart_wgpu_command_encoder_copy_buffer_to_texture?
      _wgpu_command_encoder_copy_buffer_to_texture;

  void wgpu_command_encoder_copy_texture_to_buffer(
    int command_encoder_id,
    ffi.Pointer<WGPUTextureCopyView> source,
    ffi.Pointer<WGPUBufferCopyView> destination,
    ffi.Pointer<WGPUExtent3d> copy_size,
  ) {
    return (_wgpu_command_encoder_copy_texture_to_buffer ??=
        _dylib.lookupFunction<_c_wgpu_command_encoder_copy_texture_to_buffer,
                _dart_wgpu_command_encoder_copy_texture_to_buffer>(
            'wgpu_command_encoder_copy_texture_to_buffer'))(
      command_encoder_id,
      source,
      destination,
      copy_size,
    );
  }

  _dart_wgpu_command_encoder_copy_texture_to_buffer?
      _wgpu_command_encoder_copy_texture_to_buffer;

  void wgpu_command_encoder_copy_texture_to_texture(
    int command_encoder_id,
    ffi.Pointer<WGPUTextureCopyView> source,
    ffi.Pointer<WGPUTextureCopyView> destination,
    ffi.Pointer<WGPUExtent3d> copy_size,
  ) {
    return (_wgpu_command_encoder_copy_texture_to_texture ??=
        _dylib.lookupFunction<_c_wgpu_command_encoder_copy_texture_to_texture,
                _dart_wgpu_command_encoder_copy_texture_to_texture>(
            'wgpu_command_encoder_copy_texture_to_texture'))(
      command_encoder_id,
      source,
      destination,
      copy_size,
    );
  }

  _dart_wgpu_command_encoder_copy_texture_to_texture?
      _wgpu_command_encoder_copy_texture_to_texture;

  void wgpu_command_encoder_destroy(
    int command_encoder_id,
  ) {
    return (_wgpu_command_encoder_destroy ??= _dylib.lookupFunction<
        _c_wgpu_command_encoder_destroy,
        _dart_wgpu_command_encoder_destroy>('wgpu_command_encoder_destroy'))(
      command_encoder_id,
    );
  }

  _dart_wgpu_command_encoder_destroy? _wgpu_command_encoder_destroy;

  int wgpu_command_encoder_finish(
    int encoder_id,
    ffi.Pointer<WGPUCommandBufferDescriptor> desc,
  ) {
    return (_wgpu_command_encoder_finish ??= _dylib.lookupFunction<
        _c_wgpu_command_encoder_finish,
        _dart_wgpu_command_encoder_finish>('wgpu_command_encoder_finish'))(
      encoder_id,
      desc,
    );
  }

  _dart_wgpu_command_encoder_finish? _wgpu_command_encoder_finish;

  void wgpu_compute_pass_destroy(
    ffi.Pointer<WGPUComputePass> pass,
  ) {
    return (_wgpu_compute_pass_destroy ??= _dylib.lookupFunction<
        _c_wgpu_compute_pass_destroy,
        _dart_wgpu_compute_pass_destroy>('wgpu_compute_pass_destroy'))(
      pass,
    );
  }

  _dart_wgpu_compute_pass_destroy? _wgpu_compute_pass_destroy;

  void wgpu_compute_pass_dispatch(
    ffi.Pointer<WGPUComputePass> pass,
    int groups_x,
    int groups_y,
    int groups_z,
  ) {
    return (_wgpu_compute_pass_dispatch ??= _dylib.lookupFunction<
        _c_wgpu_compute_pass_dispatch,
        _dart_wgpu_compute_pass_dispatch>('wgpu_compute_pass_dispatch'))(
      pass,
      groups_x,
      groups_y,
      groups_z,
    );
  }

  _dart_wgpu_compute_pass_dispatch? _wgpu_compute_pass_dispatch;

  void wgpu_compute_pass_dispatch_indirect(
    ffi.Pointer<WGPUComputePass> pass,
    int buffer_id,
    int offset,
  ) {
    return (_wgpu_compute_pass_dispatch_indirect ??= _dylib.lookupFunction<
            _c_wgpu_compute_pass_dispatch_indirect,
            _dart_wgpu_compute_pass_dispatch_indirect>(
        'wgpu_compute_pass_dispatch_indirect'))(
      pass,
      buffer_id,
      offset,
    );
  }

  _dart_wgpu_compute_pass_dispatch_indirect?
      _wgpu_compute_pass_dispatch_indirect;

  void wgpu_compute_pass_end_pass(
    ffi.Pointer<WGPUComputePass> pass,
  ) {
    return (_wgpu_compute_pass_end_pass ??= _dylib.lookupFunction<
        _c_wgpu_compute_pass_end_pass,
        _dart_wgpu_compute_pass_end_pass>('wgpu_compute_pass_end_pass'))(
      pass,
    );
  }

  _dart_wgpu_compute_pass_end_pass? _wgpu_compute_pass_end_pass;

  void wgpu_compute_pass_insert_debug_marker(
    ffi.Pointer<WGPUComputePass> pass,
    ffi.Pointer<ffi.Int8> label,
    int color,
  ) {
    return (_wgpu_compute_pass_insert_debug_marker ??= _dylib.lookupFunction<
            _c_wgpu_compute_pass_insert_debug_marker,
            _dart_wgpu_compute_pass_insert_debug_marker>(
        'wgpu_compute_pass_insert_debug_marker'))(
      pass,
      label,
      color,
    );
  }

  _dart_wgpu_compute_pass_insert_debug_marker?
      _wgpu_compute_pass_insert_debug_marker;

  void wgpu_compute_pass_pop_debug_group(
    ffi.Pointer<WGPUComputePass> pass,
  ) {
    return (_wgpu_compute_pass_pop_debug_group ??= _dylib.lookupFunction<
            _c_wgpu_compute_pass_pop_debug_group,
            _dart_wgpu_compute_pass_pop_debug_group>(
        'wgpu_compute_pass_pop_debug_group'))(
      pass,
    );
  }

  _dart_wgpu_compute_pass_pop_debug_group? _wgpu_compute_pass_pop_debug_group;

  void wgpu_compute_pass_push_debug_group(
    ffi.Pointer<WGPUComputePass> pass,
    ffi.Pointer<ffi.Int8> label,
    int color,
  ) {
    return (_wgpu_compute_pass_push_debug_group ??= _dylib.lookupFunction<
            _c_wgpu_compute_pass_push_debug_group,
            _dart_wgpu_compute_pass_push_debug_group>(
        'wgpu_compute_pass_push_debug_group'))(
      pass,
      label,
      color,
    );
  }

  _dart_wgpu_compute_pass_push_debug_group? _wgpu_compute_pass_push_debug_group;

  /// # Safety
  ///
  /// This function is unsafe as there is no guarantee that the given pointer is
  /// valid for `offset_length` elements.
  void wgpu_compute_pass_set_bind_group(
    ffi.Pointer<WGPUComputePass> pass,
    int index,
    int bind_group_id,
    ffi.Pointer<ffi.Uint32> offsets,
    int offset_length,
  ) {
    return (_wgpu_compute_pass_set_bind_group ??= _dylib.lookupFunction<
            _c_wgpu_compute_pass_set_bind_group,
            _dart_wgpu_compute_pass_set_bind_group>(
        'wgpu_compute_pass_set_bind_group'))(
      pass,
      index,
      bind_group_id,
      offsets,
      offset_length,
    );
  }

  _dart_wgpu_compute_pass_set_bind_group? _wgpu_compute_pass_set_bind_group;

  void wgpu_compute_pass_set_pipeline(
    ffi.Pointer<WGPUComputePass> pass,
    int pipeline_id,
  ) {
    return (_wgpu_compute_pass_set_pipeline ??= _dylib.lookupFunction<
            _c_wgpu_compute_pass_set_pipeline,
            _dart_wgpu_compute_pass_set_pipeline>(
        'wgpu_compute_pass_set_pipeline'))(
      pass,
      pipeline_id,
    );
  }

  _dart_wgpu_compute_pass_set_pipeline? _wgpu_compute_pass_set_pipeline;

  void wgpu_compute_pipeline_destroy(
    int compute_pipeline_id,
  ) {
    return (_wgpu_compute_pipeline_destroy ??= _dylib.lookupFunction<
        _c_wgpu_compute_pipeline_destroy,
        _dart_wgpu_compute_pipeline_destroy>('wgpu_compute_pipeline_destroy'))(
      compute_pipeline_id,
    );
  }

  _dart_wgpu_compute_pipeline_destroy? _wgpu_compute_pipeline_destroy;

  int wgpu_create_surface_from_android(
    ffi.Pointer<ffi.Void> a_native_window,
  ) {
    return (_wgpu_create_surface_from_android ??= _dylib.lookupFunction<
            _c_wgpu_create_surface_from_android,
            _dart_wgpu_create_surface_from_android>(
        'wgpu_create_surface_from_android'))(
      a_native_window,
    );
  }

  _dart_wgpu_create_surface_from_android? _wgpu_create_surface_from_android;

  int wgpu_create_surface_from_metal_layer(
    ffi.Pointer<ffi.Void> layer,
  ) {
    return (_wgpu_create_surface_from_metal_layer ??= _dylib.lookupFunction<
            _c_wgpu_create_surface_from_metal_layer,
            _dart_wgpu_create_surface_from_metal_layer>(
        'wgpu_create_surface_from_metal_layer'))(
      layer,
    );
  }

  _dart_wgpu_create_surface_from_metal_layer?
      _wgpu_create_surface_from_metal_layer;

  int wgpu_create_surface_from_wayland(
    ffi.Pointer<ffi.Void> surface,
    ffi.Pointer<ffi.Void> display,
  ) {
    return (_wgpu_create_surface_from_wayland ??= _dylib.lookupFunction<
            _c_wgpu_create_surface_from_wayland,
            _dart_wgpu_create_surface_from_wayland>(
        'wgpu_create_surface_from_wayland'))(
      surface,
      display,
    );
  }

  _dart_wgpu_create_surface_from_wayland? _wgpu_create_surface_from_wayland;

  int wgpu_create_surface_from_windows_hwnd(
    ffi.Pointer<ffi.Void> _hinstance,
    ffi.Pointer<ffi.Void> hwnd,
  ) {
    return (_wgpu_create_surface_from_windows_hwnd ??= _dylib.lookupFunction<
            _c_wgpu_create_surface_from_windows_hwnd,
            _dart_wgpu_create_surface_from_windows_hwnd>(
        'wgpu_create_surface_from_windows_hwnd'))(
      _hinstance,
      hwnd,
    );
  }

  _dart_wgpu_create_surface_from_windows_hwnd?
      _wgpu_create_surface_from_windows_hwnd;

  int wgpu_create_surface_from_xlib(
    ffi.Pointer<ffi.Pointer<ffi.Void>> display,
    int window,
  ) {
    return (_wgpu_create_surface_from_xlib ??= _dylib.lookupFunction<
        _c_wgpu_create_surface_from_xlib,
        _dart_wgpu_create_surface_from_xlib>('wgpu_create_surface_from_xlib'))(
      display,
      window,
    );
  }

  _dart_wgpu_create_surface_from_xlib? _wgpu_create_surface_from_xlib;

  int wgpu_device_create_bind_group(
    int device_id,
    ffi.Pointer<WGPUBindGroupDescriptor> desc,
  ) {
    return (_wgpu_device_create_bind_group ??= _dylib.lookupFunction<
        _c_wgpu_device_create_bind_group,
        _dart_wgpu_device_create_bind_group>('wgpu_device_create_bind_group'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_bind_group? _wgpu_device_create_bind_group;

  int wgpu_device_create_bind_group_layout(
    int device_id,
    ffi.Pointer<WGPUBindGroupLayoutDescriptor> desc,
  ) {
    return (_wgpu_device_create_bind_group_layout ??= _dylib.lookupFunction<
            _c_wgpu_device_create_bind_group_layout,
            _dart_wgpu_device_create_bind_group_layout>(
        'wgpu_device_create_bind_group_layout'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_bind_group_layout?
      _wgpu_device_create_bind_group_layout;

  int wgpu_device_create_buffer(
    int device_id,
    ffi.Pointer<WGPUBufferDescriptor> desc,
  ) {
    return (_wgpu_device_create_buffer ??= _dylib.lookupFunction<
        _c_wgpu_device_create_buffer,
        _dart_wgpu_device_create_buffer>('wgpu_device_create_buffer'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_buffer? _wgpu_device_create_buffer;

  int wgpu_device_create_command_encoder(
    int device_id,
    ffi.Pointer<WGPUCommandEncoderDescriptor> desc,
  ) {
    return (_wgpu_device_create_command_encoder ??= _dylib.lookupFunction<
            _c_wgpu_device_create_command_encoder,
            _dart_wgpu_device_create_command_encoder>(
        'wgpu_device_create_command_encoder'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_command_encoder? _wgpu_device_create_command_encoder;

  int wgpu_device_create_compute_pipeline(
    int device_id,
    ffi.Pointer<WGPUComputePipelineDescriptor> desc,
  ) {
    return (_wgpu_device_create_compute_pipeline ??= _dylib.lookupFunction<
            _c_wgpu_device_create_compute_pipeline,
            _dart_wgpu_device_create_compute_pipeline>(
        'wgpu_device_create_compute_pipeline'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_compute_pipeline?
      _wgpu_device_create_compute_pipeline;

  int wgpu_device_create_pipeline_layout(
    int device_id,
    ffi.Pointer<WGPUPipelineLayoutDescriptor> desc,
  ) {
    return (_wgpu_device_create_pipeline_layout ??= _dylib.lookupFunction<
            _c_wgpu_device_create_pipeline_layout,
            _dart_wgpu_device_create_pipeline_layout>(
        'wgpu_device_create_pipeline_layout'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_pipeline_layout? _wgpu_device_create_pipeline_layout;

  ffi.Pointer<WGPURenderBundleEncoder> wgpu_device_create_render_bundle_encoder(
    int device_id,
    ffi.Pointer<WGPURenderBundleEncoderDescriptor> desc,
  ) {
    return (_wgpu_device_create_render_bundle_encoder ??= _dylib.lookupFunction<
            _c_wgpu_device_create_render_bundle_encoder,
            _dart_wgpu_device_create_render_bundle_encoder>(
        'wgpu_device_create_render_bundle_encoder'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_render_bundle_encoder?
      _wgpu_device_create_render_bundle_encoder;

  int wgpu_device_create_render_pipeline(
    int device_id,
    ffi.Pointer<WGPURenderPipelineDescriptor> desc,
  ) {
    return (_wgpu_device_create_render_pipeline ??= _dylib.lookupFunction<
            _c_wgpu_device_create_render_pipeline,
            _dart_wgpu_device_create_render_pipeline>(
        'wgpu_device_create_render_pipeline'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_render_pipeline? _wgpu_device_create_render_pipeline;

  int wgpu_device_create_sampler(
    int device_id,
    ffi.Pointer<WGPUSamplerDescriptor> desc,
  ) {
    return (_wgpu_device_create_sampler ??= _dylib.lookupFunction<
        _c_wgpu_device_create_sampler,
        _dart_wgpu_device_create_sampler>('wgpu_device_create_sampler'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_sampler? _wgpu_device_create_sampler;

  int wgpu_device_create_shader_module(
    int device_id,
    WGPUShaderSource source,
  ) {
    return (_wgpu_device_create_shader_module ??= _dylib.lookupFunction<
            _c_wgpu_device_create_shader_module,
            _dart_wgpu_device_create_shader_module>(
        'wgpu_device_create_shader_module'))(
      device_id,
      source,
    );
  }

  _dart_wgpu_device_create_shader_module? _wgpu_device_create_shader_module;

  int wgpu_device_create_swap_chain(
    int device_id,
    int surface_id,
    ffi.Pointer<WGPUSwapChainDescriptor> desc,
  ) {
    return (_wgpu_device_create_swap_chain ??= _dylib.lookupFunction<
        _c_wgpu_device_create_swap_chain,
        _dart_wgpu_device_create_swap_chain>('wgpu_device_create_swap_chain'))(
      device_id,
      surface_id,
      desc,
    );
  }

  _dart_wgpu_device_create_swap_chain? _wgpu_device_create_swap_chain;

  int wgpu_device_create_texture(
    int device_id,
    ffi.Pointer<WGPUTextureDescriptor> desc,
  ) {
    return (_wgpu_device_create_texture ??= _dylib.lookupFunction<
        _c_wgpu_device_create_texture,
        _dart_wgpu_device_create_texture>('wgpu_device_create_texture'))(
      device_id,
      desc,
    );
  }

  _dart_wgpu_device_create_texture? _wgpu_device_create_texture;

  void wgpu_device_destroy(
    int device_id,
  ) {
    return (_wgpu_device_destroy ??= _dylib.lookupFunction<
        _c_wgpu_device_destroy,
        _dart_wgpu_device_destroy>('wgpu_device_destroy'))(
      device_id,
    );
  }

  _dart_wgpu_device_destroy? _wgpu_device_destroy;

  int wgpu_device_features(
    int device_id,
  ) {
    return (_wgpu_device_features ??= _dylib.lookupFunction<
        _c_wgpu_device_features,
        _dart_wgpu_device_features>('wgpu_device_features'))(
      device_id,
    );
  }

  _dart_wgpu_device_features? _wgpu_device_features;

  int wgpu_device_get_default_queue(
    int device_id,
  ) {
    return (_wgpu_device_get_default_queue ??= _dylib.lookupFunction<
        _c_wgpu_device_get_default_queue,
        _dart_wgpu_device_get_default_queue>('wgpu_device_get_default_queue'))(
      device_id,
    );
  }

  _dart_wgpu_device_get_default_queue? _wgpu_device_get_default_queue;

  WGPUCLimits wgpu_device_limits(
    int device_id,
  ) {
    return (_wgpu_device_limits ??=
        _dylib.lookupFunction<_c_wgpu_device_limits, _dart_wgpu_device_limits>(
            'wgpu_device_limits'))(
      device_id,
    );
  }

  _dart_wgpu_device_limits? _wgpu_device_limits;

  void wgpu_device_poll(
    int device_id,
    bool force_wait,
  ) {
    return (_wgpu_device_poll ??=
        _dylib.lookupFunction<_c_wgpu_device_poll, _dart_wgpu_device_poll>(
            'wgpu_device_poll'))(
      device_id,
      force_wait ? 1 : 0,
    );
  }

  _dart_wgpu_device_poll? _wgpu_device_poll;

  int wgpu_get_version() {
    return (_wgpu_get_version ??=
        _dylib.lookupFunction<_c_wgpu_get_version, _dart_wgpu_get_version>(
            'wgpu_get_version'))();
  }

  _dart_wgpu_get_version? _wgpu_get_version;

  void wgpu_pipeline_layout_destroy(
    int pipeline_layout_id,
  ) {
    return (_wgpu_pipeline_layout_destroy ??= _dylib.lookupFunction<
        _c_wgpu_pipeline_layout_destroy,
        _dart_wgpu_pipeline_layout_destroy>('wgpu_pipeline_layout_destroy'))(
      pipeline_layout_id,
    );
  }

  _dart_wgpu_pipeline_layout_destroy? _wgpu_pipeline_layout_destroy;

  /// # Safety
  ///
  /// This function is unsafe as there is no guarantee that the given `command_buffers`
  /// pointer is valid for `command_buffers_length` elements.
  void wgpu_queue_submit(
    int queue_id,
    ffi.Pointer<ffi.Uint64> command_buffers,
    int command_buffers_length,
  ) {
    return (_wgpu_queue_submit ??=
        _dylib.lookupFunction<_c_wgpu_queue_submit, _dart_wgpu_queue_submit>(
            'wgpu_queue_submit'))(
      queue_id,
      command_buffers,
      command_buffers_length,
    );
  }

  _dart_wgpu_queue_submit? _wgpu_queue_submit;

  /// # Safety
  ///
  /// This function is unsafe as there is no guarantee that the given `data`
  /// pointer is valid for `data_length` elements.
  void wgpu_queue_write_buffer(
    int queue_id,
    int buffer_id,
    int buffer_offset,
    ffi.Pointer<ffi.Uint8> data,
    int data_length,
  ) {
    return (_wgpu_queue_write_buffer ??= _dylib.lookupFunction<
        _c_wgpu_queue_write_buffer,
        _dart_wgpu_queue_write_buffer>('wgpu_queue_write_buffer'))(
      queue_id,
      buffer_id,
      buffer_offset,
      data,
      data_length,
    );
  }

  _dart_wgpu_queue_write_buffer? _wgpu_queue_write_buffer;

  /// # Safety
  ///
  /// This function is unsafe as there is no guarantee that the given `data`
  /// pointer is valid for `data_length` elements.
  void wgpu_queue_write_texture(
    int queue_id,
    ffi.Pointer<WGPUTextureCopyView> texture,
    ffi.Pointer<ffi.Uint8> data,
    int data_length,
    ffi.Pointer<WGPUTextureDataLayout> data_layout,
    ffi.Pointer<WGPUExtent3d> size,
  ) {
    return (_wgpu_queue_write_texture ??= _dylib.lookupFunction<
        _c_wgpu_queue_write_texture,
        _dart_wgpu_queue_write_texture>('wgpu_queue_write_texture'))(
      queue_id,
      texture,
      data,
      data_length,
      data_layout,
      size,
    );
  }

  _dart_wgpu_queue_write_texture? _wgpu_queue_write_texture;

  void wgpu_render_bundle_destroy(
    int render_bundle_id,
  ) {
    return (_wgpu_render_bundle_destroy ??= _dylib.lookupFunction<
        _c_wgpu_render_bundle_destroy,
        _dart_wgpu_render_bundle_destroy>('wgpu_render_bundle_destroy'))(
      render_bundle_id,
    );
  }

  _dart_wgpu_render_bundle_destroy? _wgpu_render_bundle_destroy;

  void wgpu_render_bundle_draw(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int vertex_count,
    int instance_count,
    int first_vertex,
    int first_instance,
  ) {
    return (_wgpu_render_bundle_draw ??= _dylib.lookupFunction<
        _c_wgpu_render_bundle_draw,
        _dart_wgpu_render_bundle_draw>('wgpu_render_bundle_draw'))(
      bundle,
      vertex_count,
      instance_count,
      first_vertex,
      first_instance,
    );
  }

  _dart_wgpu_render_bundle_draw? _wgpu_render_bundle_draw;

  void wgpu_render_bundle_draw_indexed(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int index_count,
    int instance_count,
    int first_index,
    int base_vertex,
    int first_instance,
  ) {
    return (_wgpu_render_bundle_draw_indexed ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_draw_indexed,
            _dart_wgpu_render_bundle_draw_indexed>(
        'wgpu_render_bundle_draw_indexed'))(
      bundle,
      index_count,
      instance_count,
      first_index,
      base_vertex,
      first_instance,
    );
  }

  _dart_wgpu_render_bundle_draw_indexed? _wgpu_render_bundle_draw_indexed;

  void wgpu_render_bundle_draw_indirect(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int buffer_id,
    int offset,
  ) {
    return (_wgpu_render_bundle_draw_indirect ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_draw_indirect,
            _dart_wgpu_render_bundle_draw_indirect>(
        'wgpu_render_bundle_draw_indirect'))(
      bundle,
      buffer_id,
      offset,
    );
  }

  _dart_wgpu_render_bundle_draw_indirect? _wgpu_render_bundle_draw_indirect;

  int wgpu_render_bundle_encoder_finish(
    ffi.Pointer<WGPURenderBundleEncoder> bundle_encoder_id,
    ffi.Pointer<WGPURenderBundleDescriptor_Label> desc,
  ) {
    return (_wgpu_render_bundle_encoder_finish ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_encoder_finish,
            _dart_wgpu_render_bundle_encoder_finish>(
        'wgpu_render_bundle_encoder_finish'))(
      bundle_encoder_id,
      desc,
    );
  }

  _dart_wgpu_render_bundle_encoder_finish? _wgpu_render_bundle_encoder_finish;

  void wgpu_render_bundle_insert_debug_marker(
    ffi.Pointer<WGPURenderBundleEncoder> _bundle,
    ffi.Pointer<ffi.Int8> _label,
  ) {
    return (_wgpu_render_bundle_insert_debug_marker ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_insert_debug_marker,
            _dart_wgpu_render_bundle_insert_debug_marker>(
        'wgpu_render_bundle_insert_debug_marker'))(
      _bundle,
      _label,
    );
  }

  _dart_wgpu_render_bundle_insert_debug_marker?
      _wgpu_render_bundle_insert_debug_marker;

  void wgpu_render_bundle_pop_debug_group(
    ffi.Pointer<WGPURenderBundleEncoder> _bundle,
  ) {
    return (_wgpu_render_bundle_pop_debug_group ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_pop_debug_group,
            _dart_wgpu_render_bundle_pop_debug_group>(
        'wgpu_render_bundle_pop_debug_group'))(
      _bundle,
    );
  }

  _dart_wgpu_render_bundle_pop_debug_group? _wgpu_render_bundle_pop_debug_group;

  void wgpu_render_bundle_push_debug_group(
    ffi.Pointer<WGPURenderBundleEncoder> _bundle,
    ffi.Pointer<ffi.Int8> _label,
  ) {
    return (_wgpu_render_bundle_push_debug_group ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_push_debug_group,
            _dart_wgpu_render_bundle_push_debug_group>(
        'wgpu_render_bundle_push_debug_group'))(
      _bundle,
      _label,
    );
  }

  _dart_wgpu_render_bundle_push_debug_group?
      _wgpu_render_bundle_push_debug_group;

  /// # Safety
  ///
  /// This function is unsafe as there is no guarantee that the given pointer is
  /// valid for `offset_length` elements.
  void wgpu_render_bundle_set_bind_group(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int index,
    int bind_group_id,
    ffi.Pointer<ffi.Uint32> offsets,
    int offset_length,
  ) {
    return (_wgpu_render_bundle_set_bind_group ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_set_bind_group,
            _dart_wgpu_render_bundle_set_bind_group>(
        'wgpu_render_bundle_set_bind_group'))(
      bundle,
      index,
      bind_group_id,
      offsets,
      offset_length,
    );
  }

  _dart_wgpu_render_bundle_set_bind_group? _wgpu_render_bundle_set_bind_group;

  void wgpu_render_bundle_set_index_buffer(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int buffer_id,
    int offset,
    WGPUOption_BufferSize size,
  ) {
    return (_wgpu_render_bundle_set_index_buffer ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_set_index_buffer,
            _dart_wgpu_render_bundle_set_index_buffer>(
        'wgpu_render_bundle_set_index_buffer'))(
      bundle,
      buffer_id,
      offset,
      size,
    );
  }

  _dart_wgpu_render_bundle_set_index_buffer?
      _wgpu_render_bundle_set_index_buffer;

  void wgpu_render_bundle_set_pipeline(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int pipeline_id,
  ) {
    return (_wgpu_render_bundle_set_pipeline ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_set_pipeline,
            _dart_wgpu_render_bundle_set_pipeline>(
        'wgpu_render_bundle_set_pipeline'))(
      bundle,
      pipeline_id,
    );
  }

  _dart_wgpu_render_bundle_set_pipeline? _wgpu_render_bundle_set_pipeline;

  void wgpu_render_bundle_set_vertex_buffer(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int slot,
    int buffer_id,
    int offset,
    WGPUOption_BufferSize size,
  ) {
    return (_wgpu_render_bundle_set_vertex_buffer ??= _dylib.lookupFunction<
            _c_wgpu_render_bundle_set_vertex_buffer,
            _dart_wgpu_render_bundle_set_vertex_buffer>(
        'wgpu_render_bundle_set_vertex_buffer'))(
      bundle,
      slot,
      buffer_id,
      offset,
      size,
    );
  }

  _dart_wgpu_render_bundle_set_vertex_buffer?
      _wgpu_render_bundle_set_vertex_buffer;

  void wgpu_render_pass_bundle_indexed_indirect(
    ffi.Pointer<WGPURenderBundleEncoder> bundle,
    int buffer_id,
    int offset,
  ) {
    return (_wgpu_render_pass_bundle_indexed_indirect ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_bundle_indexed_indirect,
            _dart_wgpu_render_pass_bundle_indexed_indirect>(
        'wgpu_render_pass_bundle_indexed_indirect'))(
      bundle,
      buffer_id,
      offset,
    );
  }

  _dart_wgpu_render_pass_bundle_indexed_indirect?
      _wgpu_render_pass_bundle_indexed_indirect;

  void wgpu_render_pass_destroy(
    ffi.Pointer<WGPURenderPass> pass,
  ) {
    return (_wgpu_render_pass_destroy ??= _dylib.lookupFunction<
        _c_wgpu_render_pass_destroy,
        _dart_wgpu_render_pass_destroy>('wgpu_render_pass_destroy'))(
      pass,
    );
  }

  _dart_wgpu_render_pass_destroy? _wgpu_render_pass_destroy;

  void wgpu_render_pass_draw(
    ffi.Pointer<WGPURenderPass> pass,
    int vertex_count,
    int instance_count,
    int first_vertex,
    int first_instance,
  ) {
    return (_wgpu_render_pass_draw ??= _dylib.lookupFunction<
        _c_wgpu_render_pass_draw,
        _dart_wgpu_render_pass_draw>('wgpu_render_pass_draw'))(
      pass,
      vertex_count,
      instance_count,
      first_vertex,
      first_instance,
    );
  }

  _dart_wgpu_render_pass_draw? _wgpu_render_pass_draw;

  void wgpu_render_pass_draw_indexed(
    ffi.Pointer<WGPURenderPass> pass,
    int index_count,
    int instance_count,
    int first_index,
    int base_vertex,
    int first_instance,
  ) {
    return (_wgpu_render_pass_draw_indexed ??= _dylib.lookupFunction<
        _c_wgpu_render_pass_draw_indexed,
        _dart_wgpu_render_pass_draw_indexed>('wgpu_render_pass_draw_indexed'))(
      pass,
      index_count,
      instance_count,
      first_index,
      base_vertex,
      first_instance,
    );
  }

  _dart_wgpu_render_pass_draw_indexed? _wgpu_render_pass_draw_indexed;

  void wgpu_render_pass_draw_indexed_indirect(
    ffi.Pointer<WGPURenderPass> pass,
    int buffer_id,
    int offset,
  ) {
    return (_wgpu_render_pass_draw_indexed_indirect ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_draw_indexed_indirect,
            _dart_wgpu_render_pass_draw_indexed_indirect>(
        'wgpu_render_pass_draw_indexed_indirect'))(
      pass,
      buffer_id,
      offset,
    );
  }

  _dart_wgpu_render_pass_draw_indexed_indirect?
      _wgpu_render_pass_draw_indexed_indirect;

  void wgpu_render_pass_draw_indirect(
    ffi.Pointer<WGPURenderPass> pass,
    int buffer_id,
    int offset,
  ) {
    return (_wgpu_render_pass_draw_indirect ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_draw_indirect,
            _dart_wgpu_render_pass_draw_indirect>(
        'wgpu_render_pass_draw_indirect'))(
      pass,
      buffer_id,
      offset,
    );
  }

  _dart_wgpu_render_pass_draw_indirect? _wgpu_render_pass_draw_indirect;

  /// # Safety
  ///
  /// This function is unsafe because improper use may lead to memory
  /// problems. For example, a double-free may occur if the function is called
  /// twice on the same raw pointer.
  void wgpu_render_pass_end_pass(
    ffi.Pointer<WGPURenderPass> pass,
  ) {
    return (_wgpu_render_pass_end_pass ??= _dylib.lookupFunction<
        _c_wgpu_render_pass_end_pass,
        _dart_wgpu_render_pass_end_pass>('wgpu_render_pass_end_pass'))(
      pass,
    );
  }

  _dart_wgpu_render_pass_end_pass? _wgpu_render_pass_end_pass;

  void wgpu_render_pass_insert_debug_marker(
    ffi.Pointer<WGPURenderPass> pass,
    ffi.Pointer<ffi.Int8> label,
    int color,
  ) {
    return (_wgpu_render_pass_insert_debug_marker ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_insert_debug_marker,
            _dart_wgpu_render_pass_insert_debug_marker>(
        'wgpu_render_pass_insert_debug_marker'))(
      pass,
      label,
      color,
    );
  }

  _dart_wgpu_render_pass_insert_debug_marker?
      _wgpu_render_pass_insert_debug_marker;

  void wgpu_render_pass_multi_draw_indexed_indirect(
    ffi.Pointer<WGPURenderPass> pass,
    int buffer_id,
    int offset,
    int count,
  ) {
    return (_wgpu_render_pass_multi_draw_indexed_indirect ??=
        _dylib.lookupFunction<_c_wgpu_render_pass_multi_draw_indexed_indirect,
                _dart_wgpu_render_pass_multi_draw_indexed_indirect>(
            'wgpu_render_pass_multi_draw_indexed_indirect'))(
      pass,
      buffer_id,
      offset,
      count,
    );
  }

  _dart_wgpu_render_pass_multi_draw_indexed_indirect?
      _wgpu_render_pass_multi_draw_indexed_indirect;

  void wgpu_render_pass_multi_draw_indexed_indirect_count(
    ffi.Pointer<WGPURenderPass> pass,
    int buffer_id,
    int offset,
    int count_buffer_id,
    int count_buffer_offset,
    int max_count,
  ) {
    return (_wgpu_render_pass_multi_draw_indexed_indirect_count ??=
        _dylib.lookupFunction<
                _c_wgpu_render_pass_multi_draw_indexed_indirect_count,
                _dart_wgpu_render_pass_multi_draw_indexed_indirect_count>(
            'wgpu_render_pass_multi_draw_indexed_indirect_count'))(
      pass,
      buffer_id,
      offset,
      count_buffer_id,
      count_buffer_offset,
      max_count,
    );
  }

  _dart_wgpu_render_pass_multi_draw_indexed_indirect_count?
      _wgpu_render_pass_multi_draw_indexed_indirect_count;

  void wgpu_render_pass_multi_draw_indirect(
    ffi.Pointer<WGPURenderPass> pass,
    int buffer_id,
    int offset,
    int count,
  ) {
    return (_wgpu_render_pass_multi_draw_indirect ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_multi_draw_indirect,
            _dart_wgpu_render_pass_multi_draw_indirect>(
        'wgpu_render_pass_multi_draw_indirect'))(
      pass,
      buffer_id,
      offset,
      count,
    );
  }

  _dart_wgpu_render_pass_multi_draw_indirect?
      _wgpu_render_pass_multi_draw_indirect;

  void wgpu_render_pass_multi_draw_indirect_count(
    ffi.Pointer<WGPURenderPass> pass,
    int buffer_id,
    int offset,
    int count_buffer_id,
    int count_buffer_offset,
    int max_count,
  ) {
    return (_wgpu_render_pass_multi_draw_indirect_count ??=
        _dylib.lookupFunction<_c_wgpu_render_pass_multi_draw_indirect_count,
                _dart_wgpu_render_pass_multi_draw_indirect_count>(
            'wgpu_render_pass_multi_draw_indirect_count'))(
      pass,
      buffer_id,
      offset,
      count_buffer_id,
      count_buffer_offset,
      max_count,
    );
  }

  _dart_wgpu_render_pass_multi_draw_indirect_count?
      _wgpu_render_pass_multi_draw_indirect_count;

  void wgpu_render_pass_pop_debug_group(
    ffi.Pointer<WGPURenderPass> pass,
  ) {
    return (_wgpu_render_pass_pop_debug_group ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_pop_debug_group,
            _dart_wgpu_render_pass_pop_debug_group>(
        'wgpu_render_pass_pop_debug_group'))(
      pass,
    );
  }

  _dart_wgpu_render_pass_pop_debug_group? _wgpu_render_pass_pop_debug_group;

  void wgpu_render_pass_push_debug_group(
    ffi.Pointer<WGPURenderPass> pass,
    ffi.Pointer<ffi.Int8> label,
    int color,
  ) {
    return (_wgpu_render_pass_push_debug_group ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_push_debug_group,
            _dart_wgpu_render_pass_push_debug_group>(
        'wgpu_render_pass_push_debug_group'))(
      pass,
      label,
      color,
    );
  }

  _dart_wgpu_render_pass_push_debug_group? _wgpu_render_pass_push_debug_group;

  /// # Safety
  ///
  /// This function is unsafe as there is no guarantee that the given pointer is
  /// valid for `offset_length` elements.
  void wgpu_render_pass_set_bind_group(
    ffi.Pointer<WGPURenderPass> pass,
    int index,
    int bind_group_id,
    ffi.Pointer<ffi.Uint32> offsets,
    int offset_length,
  ) {
    return (_wgpu_render_pass_set_bind_group ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_set_bind_group,
            _dart_wgpu_render_pass_set_bind_group>(
        'wgpu_render_pass_set_bind_group'))(
      pass,
      index,
      bind_group_id,
      offsets,
      offset_length,
    );
  }

  _dart_wgpu_render_pass_set_bind_group? _wgpu_render_pass_set_bind_group;

  void wgpu_render_pass_set_blend_color(
    ffi.Pointer<WGPURenderPass> pass,
    ffi.Pointer<WGPUColor> color,
  ) {
    return (_wgpu_render_pass_set_blend_color ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_set_blend_color,
            _dart_wgpu_render_pass_set_blend_color>(
        'wgpu_render_pass_set_blend_color'))(
      pass,
      color,
    );
  }

  _dart_wgpu_render_pass_set_blend_color? _wgpu_render_pass_set_blend_color;

  void wgpu_render_pass_set_index_buffer(
    ffi.Pointer<WGPURenderPass> pass,
    int buffer_id,
    int offset,
    WGPUOption_BufferSize size,
  ) {
    return (_wgpu_render_pass_set_index_buffer ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_set_index_buffer,
            _dart_wgpu_render_pass_set_index_buffer>(
        'wgpu_render_pass_set_index_buffer'))(
      pass,
      buffer_id,
      offset,
      size,
    );
  }

  _dart_wgpu_render_pass_set_index_buffer? _wgpu_render_pass_set_index_buffer;

  void wgpu_render_pass_set_pipeline(
    ffi.Pointer<WGPURenderPass> pass,
    int pipeline_id,
  ) {
    return (_wgpu_render_pass_set_pipeline ??= _dylib.lookupFunction<
        _c_wgpu_render_pass_set_pipeline,
        _dart_wgpu_render_pass_set_pipeline>('wgpu_render_pass_set_pipeline'))(
      pass,
      pipeline_id,
    );
  }

  _dart_wgpu_render_pass_set_pipeline? _wgpu_render_pass_set_pipeline;

  void wgpu_render_pass_set_scissor_rect(
    ffi.Pointer<WGPURenderPass> pass,
    int x,
    int y,
    int w,
    int h,
  ) {
    return (_wgpu_render_pass_set_scissor_rect ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_set_scissor_rect,
            _dart_wgpu_render_pass_set_scissor_rect>(
        'wgpu_render_pass_set_scissor_rect'))(
      pass,
      x,
      y,
      w,
      h,
    );
  }

  _dart_wgpu_render_pass_set_scissor_rect? _wgpu_render_pass_set_scissor_rect;

  void wgpu_render_pass_set_stencil_reference(
    ffi.Pointer<WGPURenderPass> pass,
    int value,
  ) {
    return (_wgpu_render_pass_set_stencil_reference ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_set_stencil_reference,
            _dart_wgpu_render_pass_set_stencil_reference>(
        'wgpu_render_pass_set_stencil_reference'))(
      pass,
      value,
    );
  }

  _dart_wgpu_render_pass_set_stencil_reference?
      _wgpu_render_pass_set_stencil_reference;

  void wgpu_render_pass_set_vertex_buffer(
    ffi.Pointer<WGPURenderPass> pass,
    int slot,
    int buffer_id,
    int offset,
    WGPUOption_BufferSize size,
  ) {
    return (_wgpu_render_pass_set_vertex_buffer ??= _dylib.lookupFunction<
            _c_wgpu_render_pass_set_vertex_buffer,
            _dart_wgpu_render_pass_set_vertex_buffer>(
        'wgpu_render_pass_set_vertex_buffer'))(
      pass,
      slot,
      buffer_id,
      offset,
      size,
    );
  }

  _dart_wgpu_render_pass_set_vertex_buffer? _wgpu_render_pass_set_vertex_buffer;

  void wgpu_render_pass_set_viewport(
    ffi.Pointer<WGPURenderPass> pass,
    double x,
    double y,
    double w,
    double h,
    double depth_min,
    double depth_max,
  ) {
    return (_wgpu_render_pass_set_viewport ??= _dylib.lookupFunction<
        _c_wgpu_render_pass_set_viewport,
        _dart_wgpu_render_pass_set_viewport>('wgpu_render_pass_set_viewport'))(
      pass,
      x,
      y,
      w,
      h,
      depth_min,
      depth_max,
    );
  }

  _dart_wgpu_render_pass_set_viewport? _wgpu_render_pass_set_viewport;

  void wgpu_render_pipeline_destroy(
    int render_pipeline_id,
  ) {
    return (_wgpu_render_pipeline_destroy ??= _dylib.lookupFunction<
        _c_wgpu_render_pipeline_destroy,
        _dart_wgpu_render_pipeline_destroy>('wgpu_render_pipeline_destroy'))(
      render_pipeline_id,
    );
  }

  _dart_wgpu_render_pipeline_destroy? _wgpu_render_pipeline_destroy;

  /// # Safety
  ///
  /// This function is unsafe as it calls an unsafe extern callback.
  void wgpu_request_adapter_async(
    ffi.Pointer<WGPURequestAdapterOptions> desc,
    int mask,
    bool allow_unsafe,
    ffi.Pointer<ffi.NativeFunction<WGPURequestAdapterCallback>> callback,
    ffi.Pointer<ffi.Void> userdata,
  ) {
    return (_wgpu_request_adapter_async ??= _dylib.lookupFunction<
        _c_wgpu_request_adapter_async,
        _dart_wgpu_request_adapter_async>('wgpu_request_adapter_async'))(
      desc,
      mask,
      allow_unsafe ? 1 : 0,
      callback,
      userdata,
    );
  }

  _dart_wgpu_request_adapter_async? _wgpu_request_adapter_async;

  void wgpu_sampler_destroy(
    int sampler_id,
  ) {
    return (_wgpu_sampler_destroy ??= _dylib.lookupFunction<
        _c_wgpu_sampler_destroy,
        _dart_wgpu_sampler_destroy>('wgpu_sampler_destroy'))(
      sampler_id,
    );
  }

  _dart_wgpu_sampler_destroy? _wgpu_sampler_destroy;

  void wgpu_set_log_callback(
    ffi.Pointer<ffi.NativeFunction<WGPULogCallback>> callback,
  ) {
    return (_wgpu_set_log_callback ??= _dylib.lookupFunction<
        _c_wgpu_set_log_callback,
        _dart_wgpu_set_log_callback>('wgpu_set_log_callback'))(
      callback,
    );
  }

  _dart_wgpu_set_log_callback? _wgpu_set_log_callback;

  int wgpu_set_log_level(
    int level,
  ) {
    return (_wgpu_set_log_level ??=
        _dylib.lookupFunction<_c_wgpu_set_log_level, _dart_wgpu_set_log_level>(
            'wgpu_set_log_level'))(
      level,
    );
  }

  _dart_wgpu_set_log_level? _wgpu_set_log_level;

  void wgpu_shader_module_destroy(
    int shader_module_id,
  ) {
    return (_wgpu_shader_module_destroy ??= _dylib.lookupFunction<
        _c_wgpu_shader_module_destroy,
        _dart_wgpu_shader_module_destroy>('wgpu_shader_module_destroy'))(
      shader_module_id,
    );
  }

  _dart_wgpu_shader_module_destroy? _wgpu_shader_module_destroy;

  WGPUSwapChainOutput wgpu_swap_chain_get_next_texture(
    int swap_chain_id,
  ) {
    return (_wgpu_swap_chain_get_next_texture ??= _dylib.lookupFunction<
            _c_wgpu_swap_chain_get_next_texture,
            _dart_wgpu_swap_chain_get_next_texture>(
        'wgpu_swap_chain_get_next_texture'))(
      swap_chain_id,
    );
  }

  _dart_wgpu_swap_chain_get_next_texture? _wgpu_swap_chain_get_next_texture;

  void wgpu_swap_chain_present(
    int swap_chain_id,
  ) {
    return (_wgpu_swap_chain_present ??= _dylib.lookupFunction<
        _c_wgpu_swap_chain_present,
        _dart_wgpu_swap_chain_present>('wgpu_swap_chain_present'))(
      swap_chain_id,
    );
  }

  _dart_wgpu_swap_chain_present? _wgpu_swap_chain_present;

  int wgpu_texture_create_view(
    int texture_id,
    ffi.Pointer<WGPUTextureViewDescriptor> desc,
  ) {
    return (_wgpu_texture_create_view ??= _dylib.lookupFunction<
        _c_wgpu_texture_create_view,
        _dart_wgpu_texture_create_view>('wgpu_texture_create_view'))(
      texture_id,
      desc,
    );
  }

  _dart_wgpu_texture_create_view? _wgpu_texture_create_view;

  void wgpu_texture_destroy(
    int texture_id,
  ) {
    return (_wgpu_texture_destroy ??= _dylib.lookupFunction<
        _c_wgpu_texture_destroy,
        _dart_wgpu_texture_destroy>('wgpu_texture_destroy'))(
      texture_id,
    );
  }

  _dart_wgpu_texture_destroy? _wgpu_texture_destroy;

  void wgpu_texture_view_destroy(
    int texture_view_id,
  ) {
    return (_wgpu_texture_view_destroy ??= _dylib.lookupFunction<
        _c_wgpu_texture_view_destroy,
        _dart_wgpu_texture_view_destroy>('wgpu_texture_view_destroy'))(
      texture_view_id,
    );
  }

  _dart_wgpu_texture_view_destroy? _wgpu_texture_view_destroy;
}

class WGPUChainedStruct extends ffi.Struct {}

/// How edges should be handled in texture addressing.
abstract class WGPUAddressMode {
  /// Clamp the value to the edge of the texture
  ///
  /// -0.25 -> 0.0
  /// 1.25  -> 1.0
  static const int WGPUAddressMode_ClampToEdge = 0;

  /// Repeat the texture in a tiling fashion
  ///
  /// -0.25 -> 0.75
  /// 1.25 -> 0.25
  static const int WGPUAddressMode_Repeat = 1;

  /// Repeat the texture, mirroring it every repeat
  ///
  /// -0.25 -> 0.25
  /// 1.25 -> 0.75
  static const int WGPUAddressMode_MirrorRepeat = 2;
}

/// Backends supported by wgpu.
abstract class WGPUBackend {
  static const int WGPUBackend_Empty = 0;
  static const int WGPUBackend_Vulkan = 1;
  static const int WGPUBackend_Metal = 2;
  static const int WGPUBackend_Dx12 = 3;
  static const int WGPUBackend_Dx11 = 4;
  static const int WGPUBackend_Gl = 5;
  static const int WGPUBackend_BrowserWebGpu = 6;
}

abstract class WGPUBindingType {
  static const int WGPUBindingType_UniformBuffer = 0;
  static const int WGPUBindingType_StorageBuffer = 1;
  static const int WGPUBindingType_ReadonlyStorageBuffer = 2;
  static const int WGPUBindingType_Sampler = 3;
  static const int WGPUBindingType_ComparisonSampler = 4;
  static const int WGPUBindingType_SampledTexture = 5;
  static const int WGPUBindingType_ReadonlyStorageTexture = 6;
  static const int WGPUBindingType_WriteonlyStorageTexture = 7;
}

/// Alpha blend factor.
///
/// Alpha blending is very complicated: see the OpenGL or Vulkan spec for more information.
abstract class WGPUBlendFactor {
  static const int WGPUBlendFactor_Zero = 0;
  static const int WGPUBlendFactor_One = 1;
  static const int WGPUBlendFactor_SrcColor = 2;
  static const int WGPUBlendFactor_OneMinusSrcColor = 3;
  static const int WGPUBlendFactor_SrcAlpha = 4;
  static const int WGPUBlendFactor_OneMinusSrcAlpha = 5;
  static const int WGPUBlendFactor_DstColor = 6;
  static const int WGPUBlendFactor_OneMinusDstColor = 7;
  static const int WGPUBlendFactor_DstAlpha = 8;
  static const int WGPUBlendFactor_OneMinusDstAlpha = 9;
  static const int WGPUBlendFactor_SrcAlphaSaturated = 10;
  static const int WGPUBlendFactor_BlendColor = 11;
  static const int WGPUBlendFactor_OneMinusBlendColor = 12;
}

/// Alpha blend operation.
///
/// Alpha blending is very complicated: see the OpenGL or Vulkan spec for more information.
abstract class WGPUBlendOperation {
  static const int WGPUBlendOperation_Add = 0;
  static const int WGPUBlendOperation_Subtract = 1;
  static const int WGPUBlendOperation_ReverseSubtract = 2;
  static const int WGPUBlendOperation_Min = 3;
  static const int WGPUBlendOperation_Max = 4;
}

abstract class WGPUBufferMapAsyncStatus {
  static const int WGPUBufferMapAsyncStatus_Success = 0;
  static const int WGPUBufferMapAsyncStatus_Error = 1;
  static const int WGPUBufferMapAsyncStatus_Unknown = 2;
  static const int WGPUBufferMapAsyncStatus_ContextLost = 3;
}

abstract class WGPUCDeviceType {
  /// Other.
  static const int WGPUCDeviceType_Other = 0;

  /// Integrated GPU with shared CPU/GPU memory.
  static const int WGPUCDeviceType_IntegratedGpu = 1;

  /// Discrete GPU with separate CPU/GPU memory.
  static const int WGPUCDeviceType_DiscreteGpu = 2;

  /// Virtual / Hosted.
  static const int WGPUCDeviceType_VirtualGpu = 3;

  /// Cpu / Software Rendering.
  static const int WGPUCDeviceType_Cpu = 4;
}

/// Comparison function used for depth and stencil operations.
abstract class WGPUCompareFunction {
  /// Invalid value, do not use
  static const int WGPUCompareFunction_Undefined = 0;

  /// Function never passes
  static const int WGPUCompareFunction_Never = 1;

  /// Function passes if new value less than existing value
  static const int WGPUCompareFunction_Less = 2;

  /// Function passes if new value is equal to existing value
  static const int WGPUCompareFunction_Equal = 3;

  /// Function passes if new value is less than or equal to existing value
  static const int WGPUCompareFunction_LessEqual = 4;

  /// Function passes if new value is greater than existing value
  static const int WGPUCompareFunction_Greater = 5;

  /// Function passes if new value is not equal to existing value
  static const int WGPUCompareFunction_NotEqual = 6;

  /// Function passes if new value is greater than or equal to existing value
  static const int WGPUCompareFunction_GreaterEqual = 7;

  /// Function always passes
  static const int WGPUCompareFunction_Always = 8;
}

/// Type of faces to be culled.
abstract class WGPUCullMode {
  /// No faces should be culled
  static const int WGPUCullMode_None = 0;

  /// Front faces should be culled
  static const int WGPUCullMode_Front = 1;

  /// Back faces should be culled
  static const int WGPUCullMode_Back = 2;
}

/// Texel mixing mode when sampling between texels.
abstract class WGPUFilterMode {
  /// Nearest neighbor sampling.
  ///
  /// This creates a pixelated effect when used as a mag filter
  static const int WGPUFilterMode_Nearest = 0;

  /// Linear Interpolation
  ///
  /// This makes textures smooth but blurry when used as a mag filter.
  static const int WGPUFilterMode_Linear = 1;
}

/// Winding order which classifies the "front" face.
abstract class WGPUFrontFace {
  /// Triangles with vertices in counter clockwise order are considered the front face.
  ///
  /// This is the default with right handed coordinate spaces.
  static const int WGPUFrontFace_Ccw = 0;

  /// Triangles with vertices in clockwise order are considered the front face.
  ///
  /// This is the default with left handed coordinate spaces.
  static const int WGPUFrontFace_Cw = 1;
}

/// Format of indices used with pipeline.
abstract class WGPUIndexFormat {
  /// Indices are 16 bit unsigned integers.
  static const int WGPUIndexFormat_Uint16 = 0;

  /// Indices are 32 bit unsigned integers.
  static const int WGPUIndexFormat_Uint32 = 1;
}

/// Rate that determines when vertex data is advanced.
abstract class WGPUInputStepMode {
  /// Input data is advanced every vertex. This is the standard value for vertex data.
  static const int WGPUInputStepMode_Vertex = 0;

  /// Input data is advanced every instance.
  static const int WGPUInputStepMode_Instance = 1;
}

/// Operation to perform to the output attachment at the start of a renderpass.
abstract class WGPULoadOp {
  /// Clear the output attachment with the clear color. Clearing is faster than loading.
  static const int WGPULoadOp_Clear = 0;

  /// Do not clear output attachment.
  static const int WGPULoadOp_Load = 1;
}

abstract class WGPULogLevel {
  static const int WGPULogLevel_Off = 0;
  static const int WGPULogLevel_Error = 1;
  static const int WGPULogLevel_Warn = 2;
  static const int WGPULogLevel_Info = 3;
  static const int WGPULogLevel_Debug = 4;
  static const int WGPULogLevel_Trace = 5;
}

/// Power Preference when choosing a physical adapter.
abstract class WGPUPowerPreference {
  /// Prefer low power when on battery, high performance when on mains.
  static const int WGPUPowerPreference_Default = 0;

  /// Adapter that uses the least possible power. This is often an integerated GPU.
  static const int WGPUPowerPreference_LowPower = 1;

  /// Adapter that has the highest performance. This is often a discrete GPU.
  static const int WGPUPowerPreference_HighPerformance = 2;
}

/// Behavior of the presentation engine based on frame rate.
abstract class WGPUPresentMode {
  /// The presentation engine does **not** wait for a vertical blanking period and
  /// the request is presented immediately. This is a low-latency presentation mode,
  /// but visible tearing may be observed. Will fallback to `Fifo` if unavailable on the
  /// selected  platform and backend. Not optimal for mobile.
  static const int WGPUPresentMode_Immediate = 0;

  /// The presentation engine waits for the next vertical blanking period to update
  /// the current image, but frames may be submitted without delay. This is a low-latency
  /// presentation mode and visible tearing will **not** be observed. Will fallback to `Fifo`
  /// if unavailable on the selected platform and backend. Not optimal for mobile.
  static const int WGPUPresentMode_Mailbox = 1;

  /// The presentation engine waits for the next vertical blanking period to update
  /// the current image. The framerate will be capped at the display refresh rate,
  /// corresponding to the `VSync`. Tearing cannot be observed. Optimal for mobile.
  static const int WGPUPresentMode_Fifo = 2;
}

/// Primitive type the input mesh is composed of.
abstract class WGPUPrimitiveTopology {
  /// Vertex data is a list of points. Each vertex is a new point.
  static const int WGPUPrimitiveTopology_PointList = 0;

  /// Vertex data is a list of lines. Each pair of vertices composes a new line.
  ///
  /// Vertices `0 1 2 3` create two lines `0 1` and `2 3`
  static const int WGPUPrimitiveTopology_LineList = 1;

  /// Vertex data is a strip of lines. Each set of two adjacent vertices form a line.
  ///
  /// Vertices `0 1 2 3` create three lines `0 1`, `1 2`, and `2 3`.
  static const int WGPUPrimitiveTopology_LineStrip = 2;

  /// Vertex data is a list of triangles. Each set of 3 vertices composes a new triangle.
  ///
  /// Vertices `0 1 2 3 4 5` create two triangles `0 1 2` and `3 4 5`
  static const int WGPUPrimitiveTopology_TriangleList = 3;

  /// Vertex data is a triangle strip. Each set of three adjacent vertices form a triangle.
  ///
  /// Vertices `0 1 2 3 4 5` creates four triangles `0 1 2`, `2 1 3`, `3 2 4`, and `4 3 5`
  static const int WGPUPrimitiveTopology_TriangleStrip = 4;
}

abstract class WGPUSType {
  static const int WGPUSType_Invalid = 0;
  static const int WGPUSType_SurfaceDescriptorFromMetalLayer = 1;
  static const int WGPUSType_SurfaceDescriptorFromWindowsHWND = 2;
  static const int WGPUSType_SurfaceDescriptorFromXlib = 3;
  static const int WGPUSType_SurfaceDescriptorFromHTMLCanvasId = 4;
  static const int WGPUSType_ShaderModuleSPIRVDescriptor = 5;
  static const int WGPUSType_ShaderModuleWGSLDescriptor = 6;

  /// Placeholder value until real value can be determined
  static const int WGPUSType_AnisotropicFiltering = 268435456;
  static const int WGPUSType_Force32 = 2147483647;
}

/// Operation to perform on the stencil value.
abstract class WGPUStencilOperation {
  /// Keep stencil value unchanged.
  static const int WGPUStencilOperation_Keep = 0;

  /// Set stencil value to zero.
  static const int WGPUStencilOperation_Zero = 1;

  /// Replace stencil value with value provided in most recent call to [`RenderPass::set_stencil_reference`].
  static const int WGPUStencilOperation_Replace = 2;

  /// Bitwise inverts stencil value.
  static const int WGPUStencilOperation_Invert = 3;

  /// Increments stencil value by one, clamping on overflow.
  static const int WGPUStencilOperation_IncrementClamp = 4;

  /// Decrements stencil value by one, clamping on underflow.
  static const int WGPUStencilOperation_DecrementClamp = 5;

  /// Increments stencil value by one, wrapping on overflow.
  static const int WGPUStencilOperation_IncrementWrap = 6;

  /// Decrements stencil value by one, wrapping on underflow.
  static const int WGPUStencilOperation_DecrementWrap = 7;
}

/// Operation to perform to the output attachment at the end of a renderpass.
abstract class WGPUStoreOp {
  /// Clear the render target. If you don't care about the contents of the target, this can be faster.
  static const int WGPUStoreOp_Clear = 0;

  /// Store the result of the renderpass.
  static const int WGPUStoreOp_Store = 1;
}

/// Status of the recieved swapchain image.
abstract class WGPUSwapChainStatus {
  static const int WGPUSwapChainStatus_Good = 0;
  static const int WGPUSwapChainStatus_Suboptimal = 1;
  static const int WGPUSwapChainStatus_Timeout = 2;
  static const int WGPUSwapChainStatus_Outdated = 3;
  static const int WGPUSwapChainStatus_Lost = 4;
  static const int WGPUSwapChainStatus_OutOfMemory = 5;
}

/// Kind of data the texture holds.
abstract class WGPUTextureAspect {
  /// Depth, Stencil, and Color.
  static const int WGPUTextureAspect_All = 0;

  /// Stencil.
  static const int WGPUTextureAspect_StencilOnly = 1;

  /// Depth.
  static const int WGPUTextureAspect_DepthOnly = 2;
}

/// Type of data shaders will read from a texture.
///
/// Only relevant for [`BindingType::SampledTexture`] bindings. See [`TextureFormat`] for more information.
abstract class WGPUTextureComponentType {
  /// They see it as a floating point number `texture1D`, `texture2D` etc
  static const int WGPUTextureComponentType_Float = 0;

  /// They see it as a signed integer `itexture1D`, `itexture2D` etc
  static const int WGPUTextureComponentType_Sint = 1;

  /// They see it as a unsigned integer `utexture1D`, `utexture2D` etc
  static const int WGPUTextureComponentType_Uint = 2;
}

/// Dimensionality of a texture.
abstract class WGPUTextureDimension {
  /// 1D texture
  static const int WGPUTextureDimension_D1 = 0;

  /// 2D texture
  static const int WGPUTextureDimension_D2 = 1;

  /// 3D texture
  static const int WGPUTextureDimension_D3 = 2;
}

/// Underlying texture data format.
///
/// If there is a conversion in the format (such as srgb -> linear), The conversion listed is for
/// loading from texture in a shader. When writing to the texture, the opposite conversion takes place.
abstract class WGPUTextureFormat {
  /// Red channel only. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
  static const int WGPUTextureFormat_R8Unorm = 0;

  /// Red channel only. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.
  static const int WGPUTextureFormat_R8Snorm = 1;

  /// Red channel only. 8 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_R8Uint = 2;

  /// Red channel only. 8 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_R8Sint = 3;

  /// Red channel only. 16 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_R16Uint = 4;

  /// Red channel only. 16 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_R16Sint = 5;

  /// Red channel only. 16 bit float per channel. Float in shader.
  static const int WGPUTextureFormat_R16Float = 6;

  /// Red and green channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
  static const int WGPUTextureFormat_Rg8Unorm = 7;

  /// Red and green channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.
  static const int WGPUTextureFormat_Rg8Snorm = 8;

  /// Red and green channels. 8 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_Rg8Uint = 9;

  /// Red and green channel s. 8 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_Rg8Sint = 10;

  /// Red channel only. 32 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_R32Uint = 11;

  /// Red channel only. 32 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_R32Sint = 12;

  /// Red channel only. 32 bit float per channel. Float in shader.
  static const int WGPUTextureFormat_R32Float = 13;

  /// Red and green channels. 16 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_Rg16Uint = 14;

  /// Red and green channels. 16 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_Rg16Sint = 15;

  /// Red and green channels. 16 bit float per channel. Float in shader.
  static const int WGPUTextureFormat_Rg16Float = 16;

  /// Red, green, blue, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
  static const int WGPUTextureFormat_Rgba8Unorm = 17;

  /// Red, green, blue, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
  static const int WGPUTextureFormat_Rgba8UnormSrgb = 18;

  /// Red, green, blue, and alpha channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.
  static const int WGPUTextureFormat_Rgba8Snorm = 19;

  /// Red, green, blue, and alpha channels. 8 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_Rgba8Uint = 20;

  /// Red, green, blue, and alpha channels. 8 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_Rgba8Sint = 21;

  /// Blue, green, red, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
  static const int WGPUTextureFormat_Bgra8Unorm = 22;

  /// Blue, green, red, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
  static const int WGPUTextureFormat_Bgra8UnormSrgb = 23;

  /// Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha) converted to/from float [0, 1] in shader.
  static const int WGPUTextureFormat_Rgb10a2Unorm = 24;

  /// Red, green, and blue channels. 11 bit float with no sign bit for RG channels. 10 bit float with no sign bti for blue channel. Float in shader.
  static const int WGPUTextureFormat_Rg11b10Float = 25;

  /// Red and green channels. 32 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_Rg32Uint = 26;

  /// Red and green channels. 32 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_Rg32Sint = 27;

  /// Red and green channels. 32 bit float per channel. Float in shader.
  static const int WGPUTextureFormat_Rg32Float = 28;

  /// Red, green, blue, and alpha channels. 16 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_Rgba16Uint = 29;

  /// Red, green, blue, and alpha channels. 16 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_Rgba16Sint = 30;

  /// Red, green, blue, and alpha channels. 16 bit float per channel. Float in shader.
  static const int WGPUTextureFormat_Rgba16Float = 31;

  /// Red, green, blue, and alpha channels. 32 bit integer per channel. Unsigned in shader.
  static const int WGPUTextureFormat_Rgba32Uint = 32;

  /// Red, green, blue, and alpha channels. 32 bit integer per channel. Signed in shader.
  static const int WGPUTextureFormat_Rgba32Sint = 33;

  /// Red, green, blue, and alpha channels. 32 bit float per channel. Float in shader.
  static const int WGPUTextureFormat_Rgba32Float = 34;

  /// Special depth format with 32 bit floating point depth.
  static const int WGPUTextureFormat_Depth32Float = 35;

  /// Special depth format with at least 24 bit integer depth.
  static const int WGPUTextureFormat_Depth24Plus = 36;

  /// Special depth/stencil format with at least 24 bit integer depth and 8 bits integer stencil.
  static const int WGPUTextureFormat_Depth24PlusStencil8 = 37;
}

/// Dimensions of a particular texture view.
abstract class WGPUTextureViewDimension {
  /// A one dimensional texture. `texture1D` in glsl shaders.
  static const int WGPUTextureViewDimension_D1 = 0;

  /// A two dimensional texture. `texture2D` in glsl shaders.
  static const int WGPUTextureViewDimension_D2 = 1;

  /// A two dimensional array texture. `texture2DArray` in glsl shaders.
  static const int WGPUTextureViewDimension_D2Array = 2;

  /// A cubemap texture. `textureCube` in glsl shaders.
  static const int WGPUTextureViewDimension_Cube = 3;

  /// A cubemap array texture. `textureCubeArray` in glsl shaders.
  static const int WGPUTextureViewDimension_CubeArray = 4;

  /// A three dimensional texture. `texture3D` in glsl shaders.
  static const int WGPUTextureViewDimension_D3 = 5;
}

/// Vertex Format for a Vertex Attribute (input).
abstract class WGPUVertexFormat {
  /// Two unsigned bytes (u8). `uvec2` in shaders.
  static const int WGPUVertexFormat_Uchar2 = 0;

  /// Four unsigned bytes (u8). `uvec4` in shaders.
  static const int WGPUVertexFormat_Uchar4 = 1;

  /// Two signed bytes (i8). `ivec2` in shaders.
  static const int WGPUVertexFormat_Char2 = 2;

  /// Four signed bytes (i8). `ivec4` in shaders.
  static const int WGPUVertexFormat_Char4 = 3;

  /// Two unsigned bytes (u8). [0, 255] converted to float [0, 1] `vec2` in shaders.
  static const int WGPUVertexFormat_Uchar2Norm = 4;

  /// Four unsigned bytes (u8). [0, 255] converted to float [0, 1] `vec4` in shaders.
  static const int WGPUVertexFormat_Uchar4Norm = 5;

  /// Two signed bytes (i8). [-127, 127] converted to float [-1, 1] `vec2` in shaders.
  static const int WGPUVertexFormat_Char2Norm = 6;

  /// Four signed bytes (i8). [-127, 127] converted to float [-1, 1] `vec4` in shaders.
  static const int WGPUVertexFormat_Char4Norm = 7;

  /// Two unsigned shorts (u16). `uvec2` in shaders.
  static const int WGPUVertexFormat_Ushort2 = 8;

  /// Four unsigned shorts (u16). `uvec4` in shaders.
  static const int WGPUVertexFormat_Ushort4 = 9;

  /// Two unsigned shorts (i16). `ivec2` in shaders.
  static const int WGPUVertexFormat_Short2 = 10;

  /// Four unsigned shorts (i16). `ivec4` in shaders.
  static const int WGPUVertexFormat_Short4 = 11;

  /// Two unsigned shorts (u16). [0, 65535] converted to float [0, 1] `vec2` in shaders.
  static const int WGPUVertexFormat_Ushort2Norm = 12;

  /// Four unsigned shorts (u16). [0, 65535] converted to float [0, 1] `vec4` in shaders.
  static const int WGPUVertexFormat_Ushort4Norm = 13;

  /// Two signed shorts (i16). [-32767, 32767] converted to float [-1, 1] `vec2` in shaders.
  static const int WGPUVertexFormat_Short2Norm = 14;

  /// Four signed shorts (i16). [-32767, 32767] converted to float [-1, 1] `vec4` in shaders.
  static const int WGPUVertexFormat_Short4Norm = 15;

  /// Two half-precision floats (no Rust equiv). `vec2` in shaders.
  static const int WGPUVertexFormat_Half2 = 16;

  /// Four half-precision floats (no Rust equiv). `vec4` in shaders.
  static const int WGPUVertexFormat_Half4 = 17;

  /// One single-precision float (f32). `float` in shaders.
  static const int WGPUVertexFormat_Float = 18;

  /// Two single-precision floats (f32). `vec2` in shaders.
  static const int WGPUVertexFormat_Float2 = 19;

  /// Three single-precision floats (f32). `vec3` in shaders.
  static const int WGPUVertexFormat_Float3 = 20;

  /// Four single-precision floats (f32). `vec4` in shaders.
  static const int WGPUVertexFormat_Float4 = 21;

  /// One unsigned int (u32). `uint` in shaders.
  static const int WGPUVertexFormat_Uint = 22;

  /// Two unsigned ints (u32). `uvec2` in shaders.
  static const int WGPUVertexFormat_Uint2 = 23;

  /// Three unsigned ints (u32). `uvec3` in shaders.
  static const int WGPUVertexFormat_Uint3 = 24;

  /// Four unsigned ints (u32). `uvec4` in shaders.
  static const int WGPUVertexFormat_Uint4 = 25;

  /// One signed int (i32). `int` in shaders.
  static const int WGPUVertexFormat_Int = 26;

  /// Two signed ints (i32). `ivec2` in shaders.
  static const int WGPUVertexFormat_Int2 = 27;

  /// Three signed ints (i32). `ivec3` in shaders.
  static const int WGPUVertexFormat_Int3 = 28;

  /// Four signed ints (i32). `ivec4` in shaders.
  static const int WGPUVertexFormat_Int4 = 29;
}

class WGPUComputePass extends ffi.Struct {}

class WGPUOption_BufferSize extends ffi.Struct {
    // ### TODO: Error: Struct 'WGPUOption_BufferSize' is empty. Empty structs are undefined behavior.
  @ffi.Uint8()
  external int dummy;
}

class WGPURenderBundleEncoder extends ffi.Struct {}

class WGPURenderPass extends ffi.Struct {}

class WGPUCAdapterInfo extends ffi.Struct {
  /// Adapter name
  external ffi.Pointer<ffi.Int8> name;

  /// Length of the adapter name
  @ffi.Uint64()
  external int name_length;

  /// Vendor PCI id of the adapter
  @ffi.Uint64()
  external int vendor;

  /// PCI id of the adapter
  @ffi.Uint64()
  external int device;

  /// Type of device
  @ffi.Uint8()
  external int device_type;

  /// Backend used for device
  @ffi.Uint8()
  external int backend;
}

class WGPUCLimits extends ffi.Struct {
  @ffi.Uint32()
  external int max_bind_groups;
}

class WGPUComputePassDescriptor extends ffi.Struct {
  @ffi.Uint32()
  external int todo;
}

/// RGBA double precision color.
///
/// This is not to be used as a generic color type, only for specific wgpu interfaces.
class WGPUColor extends ffi.Struct {
  @ffi.Double()
  external double r;

  @ffi.Double()
  external double g;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double a;
}

/// Describes an individual channel within a render pass, such as color, depth, or stencil.
class WGPUPassChannel_Color extends ffi.Struct {
  /// Operation to perform to the output attachment at the start of a renderpass. This must be clear if it
  /// is the first renderpass rendering to a swap chain image.
  @ffi.Int32()
  external int load_op;

  /// Operation to perform to the output attachment at the end of a renderpass.
  @ffi.Int32()
  external int store_op;

  /// If load_op is [`LoadOp::Clear`], the attachement will be cleared to this color.
  external WGPUColor clear_value;

  /// If true, the relevant channel is not changed by a renderpass, and the corresponding attachment
  /// can be used inside the pass by other read-only usages.
  @ffi.Uint8()
  external int read_only;
}

/// Describes a color attachment to a [`RenderPass`].
class WGPURenderPassColorAttachmentDescriptorBase_TextureViewId
    extends ffi.Struct {
  /// Texture attachment to render to. Must contain [`TextureUsage::OUTPUT_ATTACHMENT`].
  @ffi.Uint64()
  external int attachment;

  /// MSAA resolve target. Must contain [`TextureUsage::OUTPUT_ATTACHMENT`]. Must be `None` if
  /// attachment has 1 sample (does not have MSAA). This is not mandatory for rendering with multisampling,
  /// you can choose to resolve later or manually.
  @ffi.Uint64()
  external int resolve_target;

  /// Color channel.
  external WGPUPassChannel_Color channel;
}

/// Describes an individual channel within a render pass, such as color, depth, or stencil.
class WGPUPassChannel_f32 extends ffi.Struct {
  /// Operation to perform to the output attachment at the start of a renderpass. This must be clear if it
  /// is the first renderpass rendering to a swap chain image.
  @ffi.Int32()
  external int load_op;

  /// Operation to perform to the output attachment at the end of a renderpass.
  @ffi.Int32()
  external int store_op;

  /// If load_op is [`LoadOp::Clear`], the attachement will be cleared to this color.
  @ffi.Float()
  external double clear_value;

  /// If true, the relevant channel is not changed by a renderpass, and the corresponding attachment
  /// can be used inside the pass by other read-only usages.
  @ffi.Uint8()
  external int read_only;
}

/// Describes an individual channel within a render pass, such as color, depth, or stencil.
class WGPUPassChannel_u32 extends ffi.Struct {
  /// Operation to perform to the output attachment at the start of a renderpass. This must be clear if it
  /// is the first renderpass rendering to a swap chain image.
  @ffi.Int32()
  external int load_op;

  /// Operation to perform to the output attachment at the end of a renderpass.
  @ffi.Int32()
  external int store_op;

  /// If load_op is [`LoadOp::Clear`], the attachement will be cleared to this color.
  @ffi.Uint32()
  external int clear_value;

  /// If true, the relevant channel is not changed by a renderpass, and the corresponding attachment
  /// can be used inside the pass by other read-only usages.
  @ffi.Uint8()
  external int read_only;
}

/// Describes a depth/stencil attachment to a [`RenderPass`].
class WGPURenderPassDepthStencilAttachmentDescriptorBase_TextureViewId
    extends ffi.Struct {
  /// Texture attachment to render to. Must contain [`TextureUsage::OUTPUT_ATTACHMENT`] and be a valid
  /// texture type for a depth/stencil attachment.
  @ffi.Uint64()
  external int attachment;

  /// Depth channel.
  external WGPUPassChannel_f32 depth;

  /// Stencil channel.
  external WGPUPassChannel_u32 stencil;
}

class WGPURenderPassDescriptor extends ffi.Struct {
  external ffi
          .Pointer<WGPURenderPassColorAttachmentDescriptorBase_TextureViewId>
      color_attachments;

  @ffi.Uint64()
  external int color_attachments_length;

  external ffi.Pointer<
          WGPURenderPassDepthStencilAttachmentDescriptorBase_TextureViewId>
      depth_stencil_attachment;
}

/// Layout of a texture in a buffer's memory.
class WGPUTextureDataLayout extends ffi.Struct {
  /// Offset into the buffer that is the start of the texture. Must be a multiple of texture block size.
  /// For non-compressed textures, this is 1.
  @ffi.Uint64()
  external int offset;

  /// Bytes per "row" of the image. This represents one row of pixels in the x direction. Compressed
  /// textures include multiple rows of pixels in each "row". May be 0 for 1D texture copies.
  ///
  /// Must be a multiple of 256 for [`CommandEncoder::copy_buffer_to_texture`] and [`CommandEncoder::copy_texture_to_buffer`].
  /// [`Queue::write_texture`] does not have this requirement.
  ///
  /// Must be a multiple of the texture block size. For non-compressed textures, this is 1.
  @ffi.Uint32()
  external int bytes_per_row;

  /// Rows that make up a single "image". Each "image" is one layer in the z direction of a 3D image. May be larger
  /// than `copy_size.y`.
  ///
  /// May be 0 for 2D texture copies.
  @ffi.Uint32()
  external int rows_per_image;
}

class WGPUBufferCopyView extends ffi.Struct {
  @ffi.Uint64()
  external int buffer;

  external WGPUTextureDataLayout layout;
}

/// Origin of a copy to/from a texture.
class WGPUOrigin3d extends ffi.Struct {
  @ffi.Uint32()
  external int x;

  @ffi.Uint32()
  external int y;

  @ffi.Uint32()
  external int z;
}

class WGPUTextureCopyView extends ffi.Struct {
  @ffi.Uint64()
  external int texture;

  @ffi.Uint32()
  external int mip_level;

  external WGPUOrigin3d origin;
}

/// Extent of a texture related operation.
class WGPUExtent3d extends ffi.Struct {
  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;

  @ffi.Uint32()
  external int depth;
}

/// Describes a [`CommandBuffer`].
class WGPUCommandBufferDescriptor extends ffi.Struct {
  /// Set this member to zero
  @ffi.Uint32()
  external int todo;
}

class WGPUBindGroupEntry extends ffi.Struct {
  @ffi.Uint32()
  external int binding;

  @ffi.Uint64()
  external int buffer;

  @ffi.Uint64()
  external int offset;

  @ffi.Uint64()
  external int size;

  @ffi.Uint64()
  external int sampler;

  @ffi.Uint64()
  external int texture_view;
}

class WGPUBindGroupDescriptor extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> label;

  @ffi.Uint64()
  external int layout;

  external ffi.Pointer<WGPUBindGroupEntry> entries;

  @ffi.Uint64()
  external int entries_length;
}

class WGPUBindGroupLayoutEntry extends ffi.Struct {
  @ffi.Uint32()
  external int binding;

  @ffi.Uint32()
  external int visibility;

  @ffi.Uint32()
  external int ty;

  @ffi.Uint8()
  external int has_dynamic_offset;

  @ffi.Uint64()
  external int min_buffer_binding_size;

  @ffi.Uint8()
  external int multisampled;

  @ffi.Int32()
  external int view_dimension;

  @ffi.Int32()
  external int texture_component_type;

  @ffi.Int32()
  external int storage_texture_format;

  @ffi.Uint64()
  external int count;
}

class WGPUBindGroupLayoutDescriptor extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> label;

  external ffi.Pointer<WGPUBindGroupLayoutEntry> entries;

  @ffi.Uint64()
  external int entries_length;
}

/// Describes a [`Buffer`].
class WGPUBufferDescriptor extends ffi.Struct {
  /// Debug label of a buffer. This will show up in graphics debuggers for easy identification.
  external ffi.Pointer<ffi.Int8> label;

  /// Size of a buffer.
  @ffi.Uint64()
  external int size;

  /// Usages of a buffer. If the buffer is used in any way that isn't specified here, the operation
  /// will panic.
  @ffi.Uint32()
  external int usage;

  /// Allows a buffer to be mapped immediately after they are made. It does not have to be [`BufferUsage::MAP_READ`] or
  /// [`BufferUsage::MAP_WRITE`], all buffers are allowed to be mapped at creation.
  @ffi.Uint8()
  external int mapped_at_creation;
}

/// Describes a [`CommandEncoder`].
class WGPUCommandEncoderDescriptor extends ffi.Struct {
  /// Debug label for the command encoder. This will show up in graphics debuggers for easy identification.
  external ffi.Pointer<ffi.Int8> label;
}

class WGPUProgrammableStageDescriptor extends ffi.Struct {
  @ffi.Uint64()
  external int module;

  external ffi.Pointer<ffi.Int8> entry_point;
}

class WGPUComputePipelineDescriptor extends ffi.Struct {
  @ffi.Uint64()
  external int layout;

  external WGPUProgrammableStageDescriptor compute_stage;
}

class WGPUPipelineLayoutDescriptor extends ffi.Struct {
  external ffi.Pointer<ffi.Uint64> bind_group_layouts;

  @ffi.Uint64()
  external int bind_group_layouts_length;
}

class WGPURenderBundleEncoderDescriptor extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> label;

  external ffi.Pointer<ffi.Int32> color_formats;

  @ffi.Uint64()
  external int color_formats_length;

  external ffi.Pointer<ffi.Int32> depth_stencil_format;

  @ffi.Uint32()
  external int sample_count;
}

/// Describes the state of the rasterizer in a render pipeline.
class WGPURasterizationStateDescriptor extends ffi.Struct {
  @ffi.Int32()
  external int front_face;

  @ffi.Int32()
  external int cull_mode;

  @ffi.Int32()
  external int depth_bias;

  @ffi.Float()
  external double depth_bias_slope_scale;

  @ffi.Float()
  external double depth_bias_clamp;
}

/// Describes the blend state of a pipeline.
///
/// Alpha blending is very complicated: see the OpenGL or Vulkan spec for more information.
class WGPUBlendDescriptor extends ffi.Struct {
  @ffi.Int32()
  external int src_factor;

  @ffi.Int32()
  external int dst_factor;

  @ffi.Int32()
  external int operation;
}

/// Describes the color state of a render pipeline.
class WGPUColorStateDescriptor extends ffi.Struct {
  /// The [`TextureFormat`] of the image that this pipeline will render to. Must match the the format
  /// of the corresponding color attachment in [`CommandEncoder::begin_render_pass`].
  @ffi.Int32()
  external int format;

  /// The alpha blending that is used for this pipeline.
  external WGPUBlendDescriptor alpha_blend;

  /// The color blending that is used for this pipeline.
  external WGPUBlendDescriptor color_blend;

  /// Mask which enables/disables writes to different color/alpha channel.
  @ffi.Uint32()
  external int write_mask;
}

/// Describes stencil state in a render pipeline.
///
/// If you are not using stencil state, set this to [`StencilStateFaceDescriptor::IGNORE`].
class WGPUStencilStateFaceDescriptor extends ffi.Struct {
  /// Comparison function that determines if the fail_op or pass_op is used on the stencil buffer.
  @ffi.Int32()
  external int compare;

  /// Operation that is preformed when stencil test fails.
  @ffi.Int32()
  external int fail_op;

  /// Operation that is performed when depth test fails but stencil test succeeds.
  @ffi.Int32()
  external int depth_fail_op;

  /// Operation that is performed when stencil test success.
  @ffi.Int32()
  external int pass_op;
}

/// Describes the depth/stencil state in a render pipeline.
class WGPUDepthStencilStateDescriptor extends ffi.Struct {
  /// Format of the depth/stencil buffer, must be special depth format. Must match the the format
  /// of the depth/stencil attachment in [`CommandEncoder::begin_render_pass`].
  @ffi.Int32()
  external int format;

  /// If disabled, depth will not be written to.
  @ffi.Uint8()
  external int depth_write_enabled;

  /// Comparison function used to compare depth values in the depth test.
  @ffi.Int32()
  external int depth_compare;

  /// Stencil state used for front faces.
  external WGPUStencilStateFaceDescriptor stencil_front;

  /// Stencil state used for back faces.
  external WGPUStencilStateFaceDescriptor stencil_back;

  /// Stencil values are AND'd with this mask when reading and writing from the stencil buffer. Only low 8 bits are used.
  @ffi.Uint32()
  external int stencil_read_mask;

  /// Stencil values are AND'd with this mask when writing to the stencil buffer. Only low 8 bits are used.
  @ffi.Uint32()
  external int stencil_write_mask;
}

/// Vertex inputs (attributes) to shaders.
///
/// Arrays of these can be made with the [`vertex_attr_array`] macro. Vertex attributes are assumed to be tightly packed.
class WGPUVertexAttributeDescriptor extends ffi.Struct {
  /// Byte offset of the start of the input
  @ffi.Uint64()
  external int offset;

  /// Format of the input
  @ffi.Int32()
  external int format;

  /// Location for this input. Must match the location in the shader.
  @ffi.Uint32()
  external int shader_location;
}

class WGPUVertexBufferLayoutDescriptor extends ffi.Struct {
  @ffi.Uint64()
  external int array_stride;

  @ffi.Int32()
  external int step_mode;

  external ffi.Pointer<WGPUVertexAttributeDescriptor> attributes;

  @ffi.Uint64()
  external int attributes_length;
}

class WGPUVertexStateDescriptor extends ffi.Struct {
  @ffi.Int32()
  external int index_format;

  external ffi.Pointer<WGPUVertexBufferLayoutDescriptor> vertex_buffers;

  @ffi.Uint64()
  external int vertex_buffers_length;
}

class WGPURenderPipelineDescriptor extends ffi.Struct {
  @ffi.Uint64()
  external int layout;

  external WGPUProgrammableStageDescriptor vertex_stage;

  external ffi.Pointer<WGPUProgrammableStageDescriptor> fragment_stage;

  @ffi.Int32()
  external int primitive_topology;

  external ffi.Pointer<WGPURasterizationStateDescriptor> rasterization_state;

  external ffi.Pointer<WGPUColorStateDescriptor> color_states;

  @ffi.Uint64()
  external int color_states_length;

  external ffi.Pointer<WGPUDepthStencilStateDescriptor> depth_stencil_state;

  external WGPUVertexStateDescriptor vertex_state;

  @ffi.Uint32()
  external int sample_count;

  @ffi.Uint32()
  external int sample_mask;

  @ffi.Uint8()
  external int alpha_to_coverage_enabled;
}

class WGPUSamplerDescriptor extends ffi.Struct {
  external ffi.Pointer<WGPUChainedStruct> next_in_chain;

  external ffi.Pointer<ffi.Int8> label;

  @ffi.Int32()
  external int address_mode_u;

  @ffi.Int32()
  external int address_mode_v;

  @ffi.Int32()
  external int address_mode_w;

  @ffi.Int32()
  external int mag_filter;

  @ffi.Int32()
  external int min_filter;

  @ffi.Int32()
  external int mipmap_filter;

  @ffi.Float()
  external double lod_min_clamp;

  @ffi.Float()
  external double lod_max_clamp;

  @ffi.Int32()
  external int compare;
}

class WGPUShaderSource extends ffi.Struct {
  external ffi.Pointer<ffi.Uint32> bytes;

  @ffi.Uint64()
  external int length;
}

/// Describes a [`SwapChain`].
class WGPUSwapChainDescriptor extends ffi.Struct {
  /// The usage of the swap chain. The only supported usage is OUTPUT_ATTACHMENT
  @ffi.Uint32()
  external int usage;

  /// The texture format of the swap chain. The only formats that are guaranteed are
  /// `Bgra8Unorm` and `Bgra8UnormSrgb`
  @ffi.Int32()
  external int format;

  /// Width of the swap chain. Must be the same size as the surface.
  @ffi.Uint32()
  external int width;

  /// Height of the swap chain. Must be the same size as the surface.
  @ffi.Uint32()
  external int height;

  /// Presentation mode of the swap chain. FIFO is the only guaranteed to be supported, though
  /// other formats will automatically fall back to FIFO.
  @ffi.Int32()
  external int present_mode;
}

/// Describes a [`Texture`].
class WGPUTextureDescriptor extends ffi.Struct {
  /// Debug label of the texture. This will show up in graphics debuggers for easy identification.
  external ffi.Pointer<ffi.Int8> label;

  /// Size of the texture. For a regular 1D/2D texture, the unused sizes will be 1. For 2DArray textures, Z is the
  /// number of 2D textures in that array.
  external WGPUExtent3d size;

  /// Mip count of texture. For a texture with no extra mips, this must be 1.
  @ffi.Uint32()
  external int mip_level_count;

  /// Sample count of texture. If this is not 1, texture must have [`BindingType::SampledTexture::multisampled`] set to true.
  @ffi.Uint32()
  external int sample_count;

  /// Dimensions of the texture.
  @ffi.Int32()
  external int dimension;

  /// Format of the texture.
  @ffi.Int32()
  external int format;

  /// Allowed usages of the texture. If used in other ways, the operation will panic.
  @ffi.Uint32()
  external int usage;
}

/// Describes a [`RenderBundle`].
class WGPURenderBundleDescriptor_Label extends ffi.Struct {
  /// Debug label of the render bundle encoder. This will show up in graphics debuggers for easy identification.
  external ffi.Pointer<ffi.Int8> label;
}

class WGPURequestAdapterOptions extends ffi.Struct {
  @ffi.Int32()
  external int power_preference;

  @ffi.Uint64()
  external int compatible_surface;
}

class WGPUSwapChainOutput extends ffi.Struct {
  @ffi.Int32()
  external int status;

  @ffi.Uint64()
  external int view_id;
}

/// Describes a [`TextureView`].
class WGPUTextureViewDescriptor extends ffi.Struct {
  /// Debug label of the texture view. This will show up in graphics debuggers for easy identification.
  external ffi.Pointer<ffi.Int8> label;

  /// Format of the texture view. At this time, it must be the same as the underlying format of the texture.
  @ffi.Int32()
  external int format;

  /// The dimension of the texture view. For 1D textures, this must be `1D`. For 2D textures it must be one of
  /// `D2`, `D2Array`, `Cube`, and `CubeArray`. For 3D textures it must be `3D`
  @ffi.Int32()
  external int dimension;

  /// Aspect of the texture. Color textures must be [`TextureAspect::All`].
  @ffi.Int32()
  external int aspect;

  /// Base mip level.
  @ffi.Uint32()
  external int base_mip_level;

  /// Mip level count. Must be at least one. base_mip_level + level_count must be less or equal to underlying texture mip count.
  @ffi.Uint32()
  external int level_count;

  /// Base array layer.
  @ffi.Uint32()
  external int base_array_layer;

  /// Layer count. Must be at least one. base_array_layer + array_layer_count must be less or equal to the underlying array count.
  @ffi.Uint32()
  external int array_layer_count;
}

class WGPUAnisotropicSamplerDescriptorExt extends ffi.Struct {
  external ffi.Pointer<WGPUChainedStruct> next_in_chain;

  @ffi.Uint32()
  external int s_type;

  @ffi.Uint8()
  external int anisotropic_clamp;
}

const int WGPUCOPY_BYTES_PER_ROW_ALIGNMENT = 256;

const int WGPUDESIRED_NUM_FRAMES = 3;

const int WGPUMAX_ANISOTROPY = 16;

const int WGPUMAX_COLOR_TARGETS = 4;

const int WGPUMAX_MIP_LEVELS = 16;

const int WGPUMAX_VERTEX_BUFFERS = 16;

const int WGPUFeatures_MAPPABLE_PRIMARY_BUFFERS = 65536;

const int WGPUFeatures_SAMPLED_TEXTURE_BINDING_ARRAY = 131072;

const int WGPUFeatures_SAMPLED_TEXTURE_ARRAY_DYNAMIC_INDEXING = 262144;

const int WGPUFeatures_SAMPLED_TEXTURE_ARRAY_NON_UNIFORM_INDEXING = 524288;

const int WGPUFeatures_UNSIZED_BINDING_ARRAY = 1048576;

const int WGPUFeatures_MULTI_DRAW_INDIRECT = 2097152;

const int WGPUFeatures_MULTI_DRAW_INDIRECT_COUNT = 4194304;

const int WGPUFeatures_ALL_WEBGPU = 65535;

const int WGPUFeatures_ALL_UNSAFE = -281474976710656;

const int WGPUFeatures_ALL_NATIVE = -65536;

const int WGPUShaderStage_NONE = 0;

const int WGPUShaderStage_VERTEX = 1;

const int WGPUShaderStage_FRAGMENT = 2;

const int WGPUShaderStage_COMPUTE = 4;

const int WGPUBufferUsage_MAP_READ = 1;

const int WGPUBufferUsage_MAP_WRITE = 2;

const int WGPUBufferUsage_COPY_SRC = 4;

const int WGPUBufferUsage_COPY_DST = 8;

const int WGPUBufferUsage_INDEX = 16;

const int WGPUBufferUsage_VERTEX = 32;

const int WGPUBufferUsage_UNIFORM = 64;

const int WGPUBufferUsage_STORAGE = 128;

const int WGPUBufferUsage_INDIRECT = 256;

const int WGPUColorWrite_RED = 1;

const int WGPUColorWrite_GREEN = 2;

const int WGPUColorWrite_BLUE = 4;

const int WGPUColorWrite_ALPHA = 8;

const int WGPUColorWrite_COLOR = 7;

const int WGPUColorWrite_ALL = 15;

const int WGPUTextureUsage_COPY_SRC = 1;

const int WGPUTextureUsage_COPY_DST = 2;

const int WGPUTextureUsage_SAMPLED = 4;

const int WGPUTextureUsage_STORAGE = 8;

const int WGPUTextureUsage_OUTPUT_ATTACHMENT = 16;

typedef _c_wgpu_adapter_destroy = ffi.Void Function(
  ffi.Uint64 adapter_id,
);

typedef _dart_wgpu_adapter_destroy = void Function(
  int adapter_id,
);

typedef _c_wgpu_adapter_features = ffi.Uint64 Function(
  ffi.Uint64 adapter_id,
);

typedef _dart_wgpu_adapter_features = int Function(
  int adapter_id,
);

typedef _c_wgpu_adapter_get_info = ffi.Void Function(
  ffi.Uint64 adapter_id,
  ffi.Pointer<WGPUCAdapterInfo> info,
);

typedef _dart_wgpu_adapter_get_info = void Function(
  int adapter_id,
  ffi.Pointer<WGPUCAdapterInfo> info,
);

typedef _c_wgpu_adapter_limits = WGPUCLimits Function(
  ffi.Uint64 adapter_id,
);

typedef _dart_wgpu_adapter_limits = WGPUCLimits Function(
  int adapter_id,
);

typedef _c_wgpu_adapter_request_device = ffi.Uint64 Function(
  ffi.Uint64 adapter_id,
  ffi.Uint64 features,
  ffi.Pointer<WGPUCLimits> limits,
  ffi.Uint8 shader_validation,
  ffi.Pointer<ffi.Int8> trace_path,
);

typedef _dart_wgpu_adapter_request_device = int Function(
  int adapter_id,
  int features,
  ffi.Pointer<WGPUCLimits> limits,
  int shader_validation,
  ffi.Pointer<ffi.Int8> trace_path,
);

typedef _c_wgpu_bind_group_destroy = ffi.Void Function(
  ffi.Uint64 bind_group_id,
);

typedef _dart_wgpu_bind_group_destroy = void Function(
  int bind_group_id,
);

typedef _c_wgpu_bind_group_layout_destroy = ffi.Void Function(
  ffi.Uint64 bind_group_layout_id,
);

typedef _dart_wgpu_bind_group_layout_destroy = void Function(
  int bind_group_layout_id,
);

typedef _c_wgpu_buffer_destroy = ffi.Void Function(
  ffi.Uint64 buffer_id,
);

typedef _dart_wgpu_buffer_destroy = void Function(
  int buffer_id,
);

typedef _c_wgpu_buffer_get_mapped_range = ffi.Pointer<ffi.Uint8> Function(
  ffi.Uint64 buffer_id,
  ffi.Uint64 start,
  ffi.Uint64 size,
);

typedef _dart_wgpu_buffer_get_mapped_range = ffi.Pointer<ffi.Uint8> Function(
  int buffer_id,
  int start,
  int size,
);

typedef WGPUBufferMapCallback = ffi.Void Function(
  ffi.Int32,
  ffi.Pointer<ffi.Uint8>,
);

typedef _c_wgpu_buffer_map_read_async = ffi.Void Function(
  ffi.Uint64 buffer_id,
  ffi.Uint64 start,
  ffi.Uint64 size,
  ffi.Pointer<ffi.NativeFunction<WGPUBufferMapCallback>> callback,
  ffi.Pointer<ffi.Uint8> user_data,
);

typedef _dart_wgpu_buffer_map_read_async = void Function(
  int buffer_id,
  int start,
  int size,
  ffi.Pointer<ffi.NativeFunction<WGPUBufferMapCallback>> callback,
  ffi.Pointer<ffi.Uint8> user_data,
);

typedef _c_wgpu_buffer_map_write_async = ffi.Void Function(
  ffi.Uint64 buffer_id,
  ffi.Uint64 start,
  ffi.Uint64 size,
  ffi.Pointer<ffi.NativeFunction<WGPUBufferMapCallback>> callback,
  ffi.Pointer<ffi.Uint8> user_data,
);

typedef _dart_wgpu_buffer_map_write_async = void Function(
  int buffer_id,
  int start,
  int size,
  ffi.Pointer<ffi.NativeFunction<WGPUBufferMapCallback>> callback,
  ffi.Pointer<ffi.Uint8> user_data,
);

typedef _c_wgpu_buffer_unmap = ffi.Void Function(
  ffi.Uint64 buffer_id,
);

typedef _dart_wgpu_buffer_unmap = void Function(
  int buffer_id,
);

typedef _c_wgpu_command_buffer_destroy = ffi.Void Function(
  ffi.Uint64 command_buffer_id,
);

typedef _dart_wgpu_command_buffer_destroy = void Function(
  int command_buffer_id,
);

typedef _c_wgpu_command_encoder_begin_compute_pass
    = ffi.Pointer<WGPUComputePass> Function(
  ffi.Uint64 encoder_id,
  ffi.Pointer<WGPUComputePassDescriptor> _desc,
);

typedef _dart_wgpu_command_encoder_begin_compute_pass
    = ffi.Pointer<WGPUComputePass> Function(
  int encoder_id,
  ffi.Pointer<WGPUComputePassDescriptor> _desc,
);

typedef _c_wgpu_command_encoder_begin_render_pass = ffi.Pointer<WGPURenderPass>
    Function(
  ffi.Uint64 encoder_id,
  ffi.Pointer<WGPURenderPassDescriptor> desc,
);

typedef _dart_wgpu_command_encoder_begin_render_pass
    = ffi.Pointer<WGPURenderPass> Function(
  int encoder_id,
  ffi.Pointer<WGPURenderPassDescriptor> desc,
);

typedef _c_wgpu_command_encoder_copy_buffer_to_buffer = ffi.Void Function(
  ffi.Uint64 command_encoder_id,
  ffi.Uint64 source,
  ffi.Uint64 source_offset,
  ffi.Uint64 destination,
  ffi.Uint64 destination_offset,
  ffi.Uint64 size,
);

typedef _dart_wgpu_command_encoder_copy_buffer_to_buffer = void Function(
  int command_encoder_id,
  int source,
  int source_offset,
  int destination,
  int destination_offset,
  int size,
);

typedef _c_wgpu_command_encoder_copy_buffer_to_texture = ffi.Void Function(
  ffi.Uint64 command_encoder_id,
  ffi.Pointer<WGPUBufferCopyView> source,
  ffi.Pointer<WGPUTextureCopyView> destination,
  ffi.Pointer<WGPUExtent3d> copy_size,
);

typedef _dart_wgpu_command_encoder_copy_buffer_to_texture = void Function(
  int command_encoder_id,
  ffi.Pointer<WGPUBufferCopyView> source,
  ffi.Pointer<WGPUTextureCopyView> destination,
  ffi.Pointer<WGPUExtent3d> copy_size,
);

typedef _c_wgpu_command_encoder_copy_texture_to_buffer = ffi.Void Function(
  ffi.Uint64 command_encoder_id,
  ffi.Pointer<WGPUTextureCopyView> source,
  ffi.Pointer<WGPUBufferCopyView> destination,
  ffi.Pointer<WGPUExtent3d> copy_size,
);

typedef _dart_wgpu_command_encoder_copy_texture_to_buffer = void Function(
  int command_encoder_id,
  ffi.Pointer<WGPUTextureCopyView> source,
  ffi.Pointer<WGPUBufferCopyView> destination,
  ffi.Pointer<WGPUExtent3d> copy_size,
);

typedef _c_wgpu_command_encoder_copy_texture_to_texture = ffi.Void Function(
  ffi.Uint64 command_encoder_id,
  ffi.Pointer<WGPUTextureCopyView> source,
  ffi.Pointer<WGPUTextureCopyView> destination,
  ffi.Pointer<WGPUExtent3d> copy_size,
);

typedef _dart_wgpu_command_encoder_copy_texture_to_texture = void Function(
  int command_encoder_id,
  ffi.Pointer<WGPUTextureCopyView> source,
  ffi.Pointer<WGPUTextureCopyView> destination,
  ffi.Pointer<WGPUExtent3d> copy_size,
);

typedef _c_wgpu_command_encoder_destroy = ffi.Void Function(
  ffi.Uint64 command_encoder_id,
);

typedef _dart_wgpu_command_encoder_destroy = void Function(
  int command_encoder_id,
);

typedef _c_wgpu_command_encoder_finish = ffi.Uint64 Function(
  ffi.Uint64 encoder_id,
  ffi.Pointer<WGPUCommandBufferDescriptor> desc,
);

typedef _dart_wgpu_command_encoder_finish = int Function(
  int encoder_id,
  ffi.Pointer<WGPUCommandBufferDescriptor> desc,
);

typedef _c_wgpu_compute_pass_destroy = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
);

typedef _dart_wgpu_compute_pass_destroy = void Function(
  ffi.Pointer<WGPUComputePass> pass,
);

typedef _c_wgpu_compute_pass_dispatch = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Uint32 groups_x,
  ffi.Uint32 groups_y,
  ffi.Uint32 groups_z,
);

typedef _dart_wgpu_compute_pass_dispatch = void Function(
  ffi.Pointer<WGPUComputePass> pass,
  int groups_x,
  int groups_y,
  int groups_z,
);

typedef _c_wgpu_compute_pass_dispatch_indirect = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
);

typedef _dart_wgpu_compute_pass_dispatch_indirect = void Function(
  ffi.Pointer<WGPUComputePass> pass,
  int buffer_id,
  int offset,
);

typedef _c_wgpu_compute_pass_end_pass = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
);

typedef _dart_wgpu_compute_pass_end_pass = void Function(
  ffi.Pointer<WGPUComputePass> pass,
);

typedef _c_wgpu_compute_pass_insert_debug_marker = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Pointer<ffi.Int8> label,
  ffi.Uint32 color,
);

typedef _dart_wgpu_compute_pass_insert_debug_marker = void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Pointer<ffi.Int8> label,
  int color,
);

typedef _c_wgpu_compute_pass_pop_debug_group = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
);

typedef _dart_wgpu_compute_pass_pop_debug_group = void Function(
  ffi.Pointer<WGPUComputePass> pass,
);

typedef _c_wgpu_compute_pass_push_debug_group = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Pointer<ffi.Int8> label,
  ffi.Uint32 color,
);

typedef _dart_wgpu_compute_pass_push_debug_group = void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Pointer<ffi.Int8> label,
  int color,
);

typedef _c_wgpu_compute_pass_set_bind_group = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Uint32 index,
  ffi.Uint64 bind_group_id,
  ffi.Pointer<ffi.Uint32> offsets,
  ffi.Uint64 offset_length,
);

typedef _dart_wgpu_compute_pass_set_bind_group = void Function(
  ffi.Pointer<WGPUComputePass> pass,
  int index,
  int bind_group_id,
  ffi.Pointer<ffi.Uint32> offsets,
  int offset_length,
);

typedef _c_wgpu_compute_pass_set_pipeline = ffi.Void Function(
  ffi.Pointer<WGPUComputePass> pass,
  ffi.Uint64 pipeline_id,
);

typedef _dart_wgpu_compute_pass_set_pipeline = void Function(
  ffi.Pointer<WGPUComputePass> pass,
  int pipeline_id,
);

typedef _c_wgpu_compute_pipeline_destroy = ffi.Void Function(
  ffi.Uint64 compute_pipeline_id,
);

typedef _dart_wgpu_compute_pipeline_destroy = void Function(
  int compute_pipeline_id,
);

typedef _c_wgpu_create_surface_from_android = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> a_native_window,
);

typedef _dart_wgpu_create_surface_from_android = int Function(
  ffi.Pointer<ffi.Void> a_native_window,
);

typedef _c_wgpu_create_surface_from_metal_layer = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> layer,
);

typedef _dart_wgpu_create_surface_from_metal_layer = int Function(
  ffi.Pointer<ffi.Void> layer,
);

typedef _c_wgpu_create_surface_from_wayland = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> surface,
  ffi.Pointer<ffi.Void> display,
);

typedef _dart_wgpu_create_surface_from_wayland = int Function(
  ffi.Pointer<ffi.Void> surface,
  ffi.Pointer<ffi.Void> display,
);

typedef _c_wgpu_create_surface_from_windows_hwnd = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> _hinstance,
  ffi.Pointer<ffi.Void> hwnd,
);

typedef _dart_wgpu_create_surface_from_windows_hwnd = int Function(
  ffi.Pointer<ffi.Void> _hinstance,
  ffi.Pointer<ffi.Void> hwnd,
);

typedef _c_wgpu_create_surface_from_xlib = ffi.Uint64 Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> display,
  ffi.Uint64 window,
);

typedef _dart_wgpu_create_surface_from_xlib = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> display,
  int window,
);

typedef _c_wgpu_device_create_bind_group = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUBindGroupDescriptor> desc,
);

typedef _dart_wgpu_device_create_bind_group = int Function(
  int device_id,
  ffi.Pointer<WGPUBindGroupDescriptor> desc,
);

typedef _c_wgpu_device_create_bind_group_layout = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUBindGroupLayoutDescriptor> desc,
);

typedef _dart_wgpu_device_create_bind_group_layout = int Function(
  int device_id,
  ffi.Pointer<WGPUBindGroupLayoutDescriptor> desc,
);

typedef _c_wgpu_device_create_buffer = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUBufferDescriptor> desc,
);

typedef _dart_wgpu_device_create_buffer = int Function(
  int device_id,
  ffi.Pointer<WGPUBufferDescriptor> desc,
);

typedef _c_wgpu_device_create_command_encoder = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUCommandEncoderDescriptor> desc,
);

typedef _dart_wgpu_device_create_command_encoder = int Function(
  int device_id,
  ffi.Pointer<WGPUCommandEncoderDescriptor> desc,
);

typedef _c_wgpu_device_create_compute_pipeline = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUComputePipelineDescriptor> desc,
);

typedef _dart_wgpu_device_create_compute_pipeline = int Function(
  int device_id,
  ffi.Pointer<WGPUComputePipelineDescriptor> desc,
);

typedef _c_wgpu_device_create_pipeline_layout = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUPipelineLayoutDescriptor> desc,
);

typedef _dart_wgpu_device_create_pipeline_layout = int Function(
  int device_id,
  ffi.Pointer<WGPUPipelineLayoutDescriptor> desc,
);

typedef _c_wgpu_device_create_render_bundle_encoder
    = ffi.Pointer<WGPURenderBundleEncoder> Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPURenderBundleEncoderDescriptor> desc,
);

typedef _dart_wgpu_device_create_render_bundle_encoder
    = ffi.Pointer<WGPURenderBundleEncoder> Function(
  int device_id,
  ffi.Pointer<WGPURenderBundleEncoderDescriptor> desc,
);

typedef _c_wgpu_device_create_render_pipeline = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPURenderPipelineDescriptor> desc,
);

typedef _dart_wgpu_device_create_render_pipeline = int Function(
  int device_id,
  ffi.Pointer<WGPURenderPipelineDescriptor> desc,
);

typedef _c_wgpu_device_create_sampler = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUSamplerDescriptor> desc,
);

typedef _dart_wgpu_device_create_sampler = int Function(
  int device_id,
  ffi.Pointer<WGPUSamplerDescriptor> desc,
);

typedef _c_wgpu_device_create_shader_module = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  WGPUShaderSource source,
);

typedef _dart_wgpu_device_create_shader_module = int Function(
  int device_id,
  WGPUShaderSource source,
);

typedef _c_wgpu_device_create_swap_chain = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Uint64 surface_id,
  ffi.Pointer<WGPUSwapChainDescriptor> desc,
);

typedef _dart_wgpu_device_create_swap_chain = int Function(
  int device_id,
  int surface_id,
  ffi.Pointer<WGPUSwapChainDescriptor> desc,
);

typedef _c_wgpu_device_create_texture = ffi.Uint64 Function(
  ffi.Uint64 device_id,
  ffi.Pointer<WGPUTextureDescriptor> desc,
);

typedef _dart_wgpu_device_create_texture = int Function(
  int device_id,
  ffi.Pointer<WGPUTextureDescriptor> desc,
);

typedef _c_wgpu_device_destroy = ffi.Void Function(
  ffi.Uint64 device_id,
);

typedef _dart_wgpu_device_destroy = void Function(
  int device_id,
);

typedef _c_wgpu_device_features = ffi.Uint64 Function(
  ffi.Uint64 device_id,
);

typedef _dart_wgpu_device_features = int Function(
  int device_id,
);

typedef _c_wgpu_device_get_default_queue = ffi.Uint64 Function(
  ffi.Uint64 device_id,
);

typedef _dart_wgpu_device_get_default_queue = int Function(
  int device_id,
);

typedef _c_wgpu_device_limits = WGPUCLimits Function(
  ffi.Uint64 device_id,
);

typedef _dart_wgpu_device_limits = WGPUCLimits Function(
  int device_id,
);

typedef _c_wgpu_device_poll = ffi.Void Function(
  ffi.Uint64 device_id,
  ffi.Uint8 force_wait,
);

typedef _dart_wgpu_device_poll = void Function(
  int device_id,
  int force_wait,
);

typedef _c_wgpu_get_version = ffi.Uint32 Function();

typedef _dart_wgpu_get_version = int Function();

typedef _c_wgpu_pipeline_layout_destroy = ffi.Void Function(
  ffi.Uint64 pipeline_layout_id,
);

typedef _dart_wgpu_pipeline_layout_destroy = void Function(
  int pipeline_layout_id,
);

typedef _c_wgpu_queue_submit = ffi.Void Function(
  ffi.Uint64 queue_id,
  ffi.Pointer<ffi.Uint64> command_buffers,
  ffi.Uint64 command_buffers_length,
);

typedef _dart_wgpu_queue_submit = void Function(
  int queue_id,
  ffi.Pointer<ffi.Uint64> command_buffers,
  int command_buffers_length,
);

typedef _c_wgpu_queue_write_buffer = ffi.Void Function(
  ffi.Uint64 queue_id,
  ffi.Uint64 buffer_id,
  ffi.Uint64 buffer_offset,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint64 data_length,
);

typedef _dart_wgpu_queue_write_buffer = void Function(
  int queue_id,
  int buffer_id,
  int buffer_offset,
  ffi.Pointer<ffi.Uint8> data,
  int data_length,
);

typedef _c_wgpu_queue_write_texture = ffi.Void Function(
  ffi.Uint64 queue_id,
  ffi.Pointer<WGPUTextureCopyView> texture,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint64 data_length,
  ffi.Pointer<WGPUTextureDataLayout> data_layout,
  ffi.Pointer<WGPUExtent3d> size,
);

typedef _dart_wgpu_queue_write_texture = void Function(
  int queue_id,
  ffi.Pointer<WGPUTextureCopyView> texture,
  ffi.Pointer<ffi.Uint8> data,
  int data_length,
  ffi.Pointer<WGPUTextureDataLayout> data_layout,
  ffi.Pointer<WGPUExtent3d> size,
);

typedef _c_wgpu_render_bundle_destroy = ffi.Void Function(
  ffi.Uint64 render_bundle_id,
);

typedef _dart_wgpu_render_bundle_destroy = void Function(
  int render_bundle_id,
);

typedef _c_wgpu_render_bundle_draw = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint32 vertex_count,
  ffi.Uint32 instance_count,
  ffi.Uint32 first_vertex,
  ffi.Uint32 first_instance,
);

typedef _dart_wgpu_render_bundle_draw = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int vertex_count,
  int instance_count,
  int first_vertex,
  int first_instance,
);

typedef _c_wgpu_render_bundle_draw_indexed = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint32 index_count,
  ffi.Uint32 instance_count,
  ffi.Uint32 first_index,
  ffi.Int32 base_vertex,
  ffi.Uint32 first_instance,
);

typedef _dart_wgpu_render_bundle_draw_indexed = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int index_count,
  int instance_count,
  int first_index,
  int base_vertex,
  int first_instance,
);

typedef _c_wgpu_render_bundle_draw_indirect = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
);

typedef _dart_wgpu_render_bundle_draw_indirect = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int buffer_id,
  int offset,
);

typedef _c_wgpu_render_bundle_encoder_finish = ffi.Uint64 Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle_encoder_id,
  ffi.Pointer<WGPURenderBundleDescriptor_Label> desc,
);

typedef _dart_wgpu_render_bundle_encoder_finish = int Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle_encoder_id,
  ffi.Pointer<WGPURenderBundleDescriptor_Label> desc,
);

typedef _c_wgpu_render_bundle_insert_debug_marker = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> _bundle,
  ffi.Pointer<ffi.Int8> _label,
);

typedef _dart_wgpu_render_bundle_insert_debug_marker = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> _bundle,
  ffi.Pointer<ffi.Int8> _label,
);

typedef _c_wgpu_render_bundle_pop_debug_group = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> _bundle,
);

typedef _dart_wgpu_render_bundle_pop_debug_group = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> _bundle,
);

typedef _c_wgpu_render_bundle_push_debug_group = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> _bundle,
  ffi.Pointer<ffi.Int8> _label,
);

typedef _dart_wgpu_render_bundle_push_debug_group = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> _bundle,
  ffi.Pointer<ffi.Int8> _label,
);

typedef _c_wgpu_render_bundle_set_bind_group = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint32 index,
  ffi.Uint64 bind_group_id,
  ffi.Pointer<ffi.Uint32> offsets,
  ffi.Uint64 offset_length,
);

typedef _dart_wgpu_render_bundle_set_bind_group = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int index,
  int bind_group_id,
  ffi.Pointer<ffi.Uint32> offsets,
  int offset_length,
);

typedef _c_wgpu_render_bundle_set_index_buffer = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  WGPUOption_BufferSize size,
);

typedef _dart_wgpu_render_bundle_set_index_buffer = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int buffer_id,
  int offset,
  WGPUOption_BufferSize size,
);

typedef _c_wgpu_render_bundle_set_pipeline = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint64 pipeline_id,
);

typedef _dart_wgpu_render_bundle_set_pipeline = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int pipeline_id,
);

typedef _c_wgpu_render_bundle_set_vertex_buffer = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint32 slot,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  WGPUOption_BufferSize size,
);

typedef _dart_wgpu_render_bundle_set_vertex_buffer = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int slot,
  int buffer_id,
  int offset,
  WGPUOption_BufferSize size,
);

typedef _c_wgpu_render_pass_bundle_indexed_indirect = ffi.Void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
);

typedef _dart_wgpu_render_pass_bundle_indexed_indirect = void Function(
  ffi.Pointer<WGPURenderBundleEncoder> bundle,
  int buffer_id,
  int offset,
);

typedef _c_wgpu_render_pass_destroy = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
);

typedef _dart_wgpu_render_pass_destroy = void Function(
  ffi.Pointer<WGPURenderPass> pass,
);

typedef _c_wgpu_render_pass_draw = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint32 vertex_count,
  ffi.Uint32 instance_count,
  ffi.Uint32 first_vertex,
  ffi.Uint32 first_instance,
);

typedef _dart_wgpu_render_pass_draw = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int vertex_count,
  int instance_count,
  int first_vertex,
  int first_instance,
);

typedef _c_wgpu_render_pass_draw_indexed = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint32 index_count,
  ffi.Uint32 instance_count,
  ffi.Uint32 first_index,
  ffi.Int32 base_vertex,
  ffi.Uint32 first_instance,
);

typedef _dart_wgpu_render_pass_draw_indexed = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int index_count,
  int instance_count,
  int first_index,
  int base_vertex,
  int first_instance,
);

typedef _c_wgpu_render_pass_draw_indexed_indirect = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
);

typedef _dart_wgpu_render_pass_draw_indexed_indirect = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int buffer_id,
  int offset,
);

typedef _c_wgpu_render_pass_draw_indirect = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
);

typedef _dart_wgpu_render_pass_draw_indirect = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int buffer_id,
  int offset,
);

typedef _c_wgpu_render_pass_end_pass = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
);

typedef _dart_wgpu_render_pass_end_pass = void Function(
  ffi.Pointer<WGPURenderPass> pass,
);

typedef _c_wgpu_render_pass_insert_debug_marker = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Pointer<ffi.Int8> label,
  ffi.Uint32 color,
);

typedef _dart_wgpu_render_pass_insert_debug_marker = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Pointer<ffi.Int8> label,
  int color,
);

typedef _c_wgpu_render_pass_multi_draw_indexed_indirect = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  ffi.Uint32 count,
);

typedef _dart_wgpu_render_pass_multi_draw_indexed_indirect = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int buffer_id,
  int offset,
  int count,
);

typedef _c_wgpu_render_pass_multi_draw_indexed_indirect_count = ffi.Void
    Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  ffi.Uint64 count_buffer_id,
  ffi.Uint64 count_buffer_offset,
  ffi.Uint32 max_count,
);

typedef _dart_wgpu_render_pass_multi_draw_indexed_indirect_count = void
    Function(
  ffi.Pointer<WGPURenderPass> pass,
  int buffer_id,
  int offset,
  int count_buffer_id,
  int count_buffer_offset,
  int max_count,
);

typedef _c_wgpu_render_pass_multi_draw_indirect = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  ffi.Uint32 count,
);

typedef _dart_wgpu_render_pass_multi_draw_indirect = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int buffer_id,
  int offset,
  int count,
);

typedef _c_wgpu_render_pass_multi_draw_indirect_count = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  ffi.Uint64 count_buffer_id,
  ffi.Uint64 count_buffer_offset,
  ffi.Uint32 max_count,
);

typedef _dart_wgpu_render_pass_multi_draw_indirect_count = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int buffer_id,
  int offset,
  int count_buffer_id,
  int count_buffer_offset,
  int max_count,
);

typedef _c_wgpu_render_pass_pop_debug_group = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
);

typedef _dart_wgpu_render_pass_pop_debug_group = void Function(
  ffi.Pointer<WGPURenderPass> pass,
);

typedef _c_wgpu_render_pass_push_debug_group = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Pointer<ffi.Int8> label,
  ffi.Uint32 color,
);

typedef _dart_wgpu_render_pass_push_debug_group = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Pointer<ffi.Int8> label,
  int color,
);

typedef _c_wgpu_render_pass_set_bind_group = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint32 index,
  ffi.Uint64 bind_group_id,
  ffi.Pointer<ffi.Uint32> offsets,
  ffi.Uint64 offset_length,
);

typedef _dart_wgpu_render_pass_set_bind_group = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int index,
  int bind_group_id,
  ffi.Pointer<ffi.Uint32> offsets,
  int offset_length,
);

typedef _c_wgpu_render_pass_set_blend_color = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Pointer<WGPUColor> color,
);

typedef _dart_wgpu_render_pass_set_blend_color = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Pointer<WGPUColor> color,
);

typedef _c_wgpu_render_pass_set_index_buffer = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  WGPUOption_BufferSize size,
);

typedef _dart_wgpu_render_pass_set_index_buffer = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int buffer_id,
  int offset,
  WGPUOption_BufferSize size,
);

typedef _c_wgpu_render_pass_set_pipeline = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint64 pipeline_id,
);

typedef _dart_wgpu_render_pass_set_pipeline = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int pipeline_id,
);

typedef _c_wgpu_render_pass_set_scissor_rect = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint32 x,
  ffi.Uint32 y,
  ffi.Uint32 w,
  ffi.Uint32 h,
);

typedef _dart_wgpu_render_pass_set_scissor_rect = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int x,
  int y,
  int w,
  int h,
);

typedef _c_wgpu_render_pass_set_stencil_reference = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint32 value,
);

typedef _dart_wgpu_render_pass_set_stencil_reference = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int value,
);

typedef _c_wgpu_render_pass_set_vertex_buffer = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Uint32 slot,
  ffi.Uint64 buffer_id,
  ffi.Uint64 offset,
  WGPUOption_BufferSize size,
);

typedef _dart_wgpu_render_pass_set_vertex_buffer = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  int slot,
  int buffer_id,
  int offset,
  WGPUOption_BufferSize size,
);

typedef _c_wgpu_render_pass_set_viewport = ffi.Void Function(
  ffi.Pointer<WGPURenderPass> pass,
  ffi.Float x,
  ffi.Float y,
  ffi.Float w,
  ffi.Float h,
  ffi.Float depth_min,
  ffi.Float depth_max,
);

typedef _dart_wgpu_render_pass_set_viewport = void Function(
  ffi.Pointer<WGPURenderPass> pass,
  double x,
  double y,
  double w,
  double h,
  double depth_min,
  double depth_max,
);

typedef _c_wgpu_render_pipeline_destroy = ffi.Void Function(
  ffi.Uint64 render_pipeline_id,
);

typedef _dart_wgpu_render_pipeline_destroy = void Function(
  int render_pipeline_id,
);

typedef WGPURequestAdapterCallback = ffi.Void Function(
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef _c_wgpu_request_adapter_async = ffi.Void Function(
  ffi.Pointer<WGPURequestAdapterOptions> desc,
  ffi.Uint32 mask,
  ffi.Uint8 allow_unsafe,
  ffi.Pointer<ffi.NativeFunction<WGPURequestAdapterCallback>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _dart_wgpu_request_adapter_async = void Function(
  ffi.Pointer<WGPURequestAdapterOptions> desc,
  int mask,
  int allow_unsafe,
  ffi.Pointer<ffi.NativeFunction<WGPURequestAdapterCallback>> callback,
  ffi.Pointer<ffi.Void> userdata,
);

typedef _c_wgpu_sampler_destroy = ffi.Void Function(
  ffi.Uint64 sampler_id,
);

typedef _dart_wgpu_sampler_destroy = void Function(
  int sampler_id,
);

typedef WGPULogCallback = ffi.Void Function(
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
);

typedef _c_wgpu_set_log_callback = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<WGPULogCallback>> callback,
);

typedef _dart_wgpu_set_log_callback = void Function(
  ffi.Pointer<ffi.NativeFunction<WGPULogCallback>> callback,
);

typedef _c_wgpu_set_log_level = ffi.Int32 Function(
  ffi.Int32 level,
);

typedef _dart_wgpu_set_log_level = int Function(
  int level,
);

typedef _c_wgpu_shader_module_destroy = ffi.Void Function(
  ffi.Uint64 shader_module_id,
);

typedef _dart_wgpu_shader_module_destroy = void Function(
  int shader_module_id,
);

typedef _c_wgpu_swap_chain_get_next_texture = WGPUSwapChainOutput Function(
  ffi.Uint64 swap_chain_id,
);

typedef _dart_wgpu_swap_chain_get_next_texture = WGPUSwapChainOutput Function(
  int swap_chain_id,
);

typedef _c_wgpu_swap_chain_present = ffi.Void Function(
  ffi.Uint64 swap_chain_id,
);

typedef _dart_wgpu_swap_chain_present = void Function(
  int swap_chain_id,
);

typedef _c_wgpu_texture_create_view = ffi.Uint64 Function(
  ffi.Uint64 texture_id,
  ffi.Pointer<WGPUTextureViewDescriptor> desc,
);

typedef _dart_wgpu_texture_create_view = int Function(
  int texture_id,
  ffi.Pointer<WGPUTextureViewDescriptor> desc,
);

typedef _c_wgpu_texture_destroy = ffi.Void Function(
  ffi.Uint64 texture_id,
);

typedef _dart_wgpu_texture_destroy = void Function(
  int texture_id,
);

typedef _c_wgpu_texture_view_destroy = ffi.Void Function(
  ffi.Uint64 texture_view_id,
);

typedef _dart_wgpu_texture_view_destroy = void Function(
  int texture_view_id,
);
